<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Hg_SOM</title>
<script>
MathJax = {
  tex: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    tags: 'all'
  }
};
</script>
<script type="text/javascript" async 
src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<style>
body > * {
  max-width: 42em;
}
body {
  font-family: "Roboto Condensed", sans-serif;
  padding-left: 7.5em;
  padding-right: 7.5em;
}
pre, code {
  max-width: 50em;
  font-family: monospace;
}
pre.oct-code {
  border: 1px solid Grey;
  padding: 5px;
}
pre.oct-code-output {
  margin-left: 2em;
}
span.comment {
  color: ForestGreen;
}
span.keyword {
  color: Blue;
}
span.string {
  color: DarkOrchid;
}
footer {
  margin-top: 2em;
  font-size: 80%;
}
a, a:visited {
  color: Blue;
}
h2 {
  font-family: "Roboto Condensed", serif;
  margin-top: 1.5em;
}
h2 a, h2 a:visited {
  color: Black;
}
</style>

</head>
<body>
<h1>Hg_SOM</h1>

<h2>Contents</h2>
<ul>
<li><a href="#node1">============================================================</a></li>
<li><a href="#node2">========================= START ============================</a></li>
<li><a href="#node3">============================================================</a></li>
<li><a href="#node4">============================================================</a></li>
<li><a href="#node5">================= OCTAVE Needed Packages ===================</a></li>
<li><a href="#node6">============================================================</a></li>
<li><a href="#node7">============================================================</a></li>
<li><a href="#node8">================ Rosati's Hg Observations ==================</a></li>
<li><a href="#node9">============================================================</a></li>
<li><a href="#node10">===================== 0. Load data =====================</a></li>
<li><a href="#node11">===================== 1. Data into structure =====================</a></li>
<li><a href="#node12">===================== 2. Normalize data =====================</a></li>
<li><a href="#node13">===================== 3. Create, initialize and train a SOM. =====================</a></li>
<li><a href="#node14">===================== 4. Find Final BEST-MATCHING UNITS (BMUs) =====================</a></li>
<li><a href="#node15">===================== 5. SOM quality metrics =====================</a></li>
<li><a href="#node16">===================== 6. Save results =====================</a></li>
<li><a href="#node17">=====================================================</a></li>
<li><a href="#node18">===== PLOTS ===== PLOTS ===== PLOTS ===== PLOTS =====</a></li>
<li><a href="#node19">=====================================================</a></li>
<li><a href="#node20">===================== 7. Visualize component planes =====================</a></li>
<li><a href="#node21">===================== 8. Hit Plots =====================</a></li>
<li><a href="#node22">===================== 9. Map SOM units back to coordinates =====================    % NOT USEFUL OUTPUT PRODUCED</a></li>
<li><a href="#node23">============================================================</a></li>
<li><a href="#node24">================== Cossarini's Model Data ==================</a></li>
<li><a href="#node25">============================================================</a></li>
<li><a href="#node26">===================== 1. Initialise =====================</a></li>
<li><a href="#node27">===================== 2. Load .nc files =====================</a></li>
<li><a href="#node28">=============================================================</a></li>
<li><a href="#node29">============= SAVING LOOP FOR MULTIPLE Z-LEVELS =============</a></li>
<li><a href="#node30">=============================================================</a></li>
<li><a href="#node31">===================== 1. Initialise =====================</a></li>
<li><a href="#node32">=================== 2. Load .nc files ===================</a></li>
<li><a href="#node33">===================== 3. Loop over depth slices =====================</a></li>
<li><a href="#node34">=============================================================</a></li>
<li><a href="#node35">===================== ROSATI MODEL ==========================</a></li>
<li><a href="#node36">=============================================================</a></li>
<li><a href="#node37">===================== 1. Loop over depth slices =====================</a></li>
<li><a href="#node38">============================================================</a></li>
<li><a href="#node39">====================== ERROR MEASURE =======================</a></li>
<li><a href="#node40">============================================================</a></li>
<li><a href="#node41">============ Load Data ============</a></li>
<li><a href="#node42">============ Custom Red-White-Blue Colorbar ============</a></li>
<li><a href="#node43">============ Main Loop ============</a></li>
<li><a href="#node44">============================================================</a></li>
<li><a href="#node45">===================== CLOSE ALL PLOTS ======================</a></li>
<li><a href="#node46">============================================================</a></li>
</ul>

<pre class="oct-code"><span class="comment">% SOM Tool Box original files at http://www.cis.hut.fi/somtoolbox/download/, click on [SOM Toolbox 2.0 (Mar 17 2005)]</span>
<span class="comment">% The "somtoolbox" folder is identical to the original except for the file "som_make" which now allows algorithm, initalg, mapsize and training to be selected from here</span>
<span class="comment">% The experiments were performed using "Octave-10.3.0" during the October of 2025.</span>
<span class="comment">% List of the files:</span>
<span class="comment">%   Cossarini_Model_Output/</span>
<span class="comment">%             20200101_y-CMCC--PSAL-MFSe3r1-MED-b20220901_re-sv01.00.nc</span>
<span class="comment">%             20200101_y-CMCC--TEMP-MFSe3r1-MED-b20220901_re-sv01.00.nc</span>
<span class="comment">%             20200101_y-OGS--BIOL-MedBFM3-MED-b20221120_re-sv05.00.nc</span>
<span class="comment">%   Rosati_Data_Model_Output/</span>
<span class="comment">%             ave.20140616-00_00_00.DMHg.nc</span>
<span class="comment">%             ave.20140616-00_00_00.MMHg.nc</span>
<span class="comment">%             data_ancillary_DGM.csv</span>
<span class="comment">%             data_ancillary_HgT.csv</span>
<span class="comment">%             data_ancillary_MeHg.csv</span>
<span class="comment">%   somtoolbox/</span>
<span class="comment">%             SOM original scripts</span>
<span class="comment">%   Puglia_Hg_SOM.m (THIS FILE)</span>
</pre>
<h2><a id="node1">============================================================</a></h2><h2><a id="node2">========================= START ============================</a></h2><h2><a id="node3">============================================================</a></h2>
<pre class="oct-code">clc                                                                                                  <span class="comment">% Clean command window</span>
clear                                                                                                <span class="comment">% Clean workspace</span>
DIR = <span class="string">"C:/Users/mpuglia/OneDrive - OGS/Desktop/Puglia_Bandelj_Cossarini_Rosati_Experiment_10-2025"</span>;  <span class="comment">% Main Path</span>
cd(DIR)                                                                                              <span class="comment">% Set directory</span>
addpath(<span class="string">'somtoolbox'</span>);                                                                               <span class="comment">% Path to the original functions</span>
</pre>

<pre class="oct-code-output">error: C:/Users/mpuglia/OneDrive - OGS/Desktop/Puglia_Bandelj_Cossarini_Rosati_Experiment_10-2025: No such file or directory
	in:

clc                                                                                                  % Clean command window
clear                                                                                                % Clean workspace
DIR = "C:/Users/mpuglia/OneDrive - OGS/Desktop/Puglia_Bandelj_Cossarini_Rosati_Experiment_10-2025";  % Main Path
cd(DIR)                                                                                              % Set directory
addpath('somtoolbox');                                                                               % Path to the original functions



</pre>
<h2><a id="node4">============================================================</a></h2><h2><a id="node5">================= OCTAVE Needed Packages ===================</a></h2><h2><a id="node6">============================================================</a></h2>
<pre class="oct-code"><span class="comment">%pkg install -forge netcdf         % Install the NetCDF package (uncomment if not installed)</span>
pkg load netcdf                    <span class="comment">% Load the NetCDF package in Octave</span>
pkg load io                        <span class="comment">% Only needed if the io package is not already loaded</span>
</pre>
<h2><a id="node7">============================================================</a></h2><h2><a id="node8">================ Rosati's Hg Observations ==================</a></h2><h2><a id="node9">============================================================</a></h2><h2><a id="node10">===================== 0. Load data =====================</a></h2>
<pre class="oct-code">dataset = csvread(<span class="string">'Rosati_Data_Model_Output/data_ancillary_MeHg.csv'</span>, 1, 0);     <span class="comment">% Load dataset</span>
datasetval = dataset(:, [9 10 11 12]);                                           <span class="comment">% Select MeHg/HgT, Temp, Sal, O2 observations</span>
<span class="comment">%datasetval = dataset(:, [11 16 17 18]);                                         % Select DGM, Temp, Sal, O2 observations</span>
</pre>
<h2><a id="node11">===================== 1. Data into structure =====================</a></h2>
<pre class="oct-code">sData = som_data_struct(datasetval, <span class="string">'name'</span>, <span class="string">'MeHg Dataset'</span>, <span class="string">'comp_names'</span>, {<span class="string">'MeHg'</span>,<span class="string">'Temp'</span>,<span class="string">'Sal'</span>,<span class="string">'O2_uM'</span>});  <span class="comment">% Wrap in SOM Toolbox data structure</span>
</pre>

<pre class="oct-code-output">error: 'som_data_struct' undefined near line 1, column 9
	in:

sData = som_data_struct(datasetval, 'name', 'MeHg Dataset', 'comp_names', {'MeHg','Temp','Sal','O2_uM'});  % Wrap in SOM Toolbox data structure

</pre>
<h2><a id="node12">===================== 2. Normalize data =====================</a></h2>
<pre class="oct-code">sData = som_normalize(sData, <span class="string">'var'</span>);                    <span class="comment">% Normalize data</span>
</pre>

<pre class="oct-code-output">error: 'sData' undefined near line 1, column 23
	in:


sData = som_normalize(sData, 'var');                    % Normalize data

</pre>
<h2><a id="node13">===================== 3. Create, initialize and train a SOM. =====================</a></h2>
<p>'algorithm'  *(string) training: 'seq' or 'batch' (default) or 'sompak'
'init'       *(string) initialization: 'randinit' or 'lininit' (default)
'mapsize'    *(string) do you want a 'small', 'normal' or 'big' map
'training'    (string) 'short', 'default' or 'long'</p>

<pre class="oct-code">algorithm = <span class="string">'seq'</span>;                                              <span class="comment">% Selected: 'seq'/'batch'</span>
initalg = <span class="string">'lininit'</span>;                                            <span class="comment">% Selected: 'lininit'</span>
mapsize = <span class="string">'big'</span>;                                                <span class="comment">% Selected: 'big'</span>
training = <span class="string">'long'</span>;                                              <span class="comment">% Selected: 'long'</span>
sMap = som_make(sData, algorithm, initalg, mapsize, training);  <span class="comment">% Train the SOM with sData and specified options</span>

clear algorithm initalg mapsize training                        <span class="comment">% Clear temporary variables from workspace</span>
</pre>

<pre class="oct-code-output">error: 'sData' undefined near line 1, column 17
	in:

algorithm = 'seq';                                              % Selected: 'seq'/'batch'
initalg = 'lininit';                                            % Selected: 'lininit'
mapsize = 'big';                                                % Selected: 'big'
training = 'long';                                              % Selected: 'long'
sMap = som_make(sData, algorithm, initalg, mapsize, training);  % Train the SOM with sData and specified options

clear algorithm initalg mapsize training                        % Clear temporary variables from workspace
</pre>
<h2><a id="node14">===================== 4. Find Final BEST-MATCHING UNITS (BMUs) =====================</a></h2>
<pre class="oct-code">bmus = som_bmus(sMap, sData);                           <span class="comment">% Find the Best-Matching Unit (BMU) for each data sample in sData using the trained SOM</span>
</pre>

<pre class="oct-code-output">error: 'sMap' undefined near line 1, column 17
	in:

bmus = som_bmus(sMap, sData);                           % Find the Best-Matching Unit (BMU) for each data sample in sData using the trained SOM

</pre>
<h2><a id="node15">===================== 5. SOM quality metrics =====================</a></h2>
<pre class="oct-code">[q, t] = som_quality(sMap, sData);                      <span class="comment">% Compute SOM quality metrics: q = quantization error, t = topographic error</span>
</pre>

<pre class="oct-code-output">error: 'sMap' undefined near line 1, column 22
	in:

[q, t] = som_quality(sMap, sData);                      % Compute SOM quality metrics: q = quantization error, t = topographic error

</pre>
<h2><a id="node16">===================== 6. Save results =====================</a></h2>
<pre class="oct-code">save(<span class="string">'C:\Users\mpuglia\MeHg_Rosati_SOM_Observations.mat'</span>)</pre>
<h2><a id="node17">=====================================================</a></h2><h2><a id="node18">===== PLOTS ===== PLOTS ===== PLOTS ===== PLOTS =====</a></h2><h2><a id="node19">=====================================================</a></h2><h2><a id="node20">===================== 7. Visualize component planes =====================</a></h2>
<pre class="oct-code">figure(1);                                       <span class="comment">% Open figure</span>

colormap(1-gray)                                 <span class="comment">% Use an inverted grayscale colormap for better contrast</span>
som_show(sMap, <span class="string">'norm'</span>, <span class="string">'d'</span>);                     <span class="comment">% Display the SOM component planes normalized by distance</span>
text(1, -7, <span class="string">'Component planes for MeHg'</span>, ...     <span class="comment">% Add a title text to the figure at position (1, -7)</span>
     <span class="string">'HorizontalAlignment'</span>, <span class="string">'center'</span>, ...        <span class="comment">% Center the text horizontally</span>
     <span class="string">'FontSize'</span>, 14, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);      <span class="comment">% Use larger, bold font for emphasis</span>
saveas(gcf, <span class="string">'MeHg_SOM_component_planes.png'</span>);    <span class="comment">% Save as PNG</span>
</pre>

<pre class="oct-code-output">error: 'sMap' undefined near line 1, column 10
	in:

figure(1);                                       % Open figure

colormap(1-gray)                                 % Use an inverted grayscale colormap for better contrast
som_show(sMap, 'norm', 'd');                     % Display the SOM component planes normalized by distance
text(1, -7, 'Component planes for MeHg', ...     % Add a title text to the figure at position (1, -7)
     'HorizontalAlignment', 'center', ...        % Center the text horizontally
     'FontSize', 14, 'FontWeight', 'bold');      % Use larger, bold font for emphasis
saveas(gcf, 'MeHg_SOM_component_planes.png');    % Save as PNG

</pre>
<h2><a id="node21">===================== 8. Hit Plots =====================</a></h2>
<pre class="oct-code">hit = som_hits(sMap, sData);                     <span class="comment">% Compute the number of data samples (hits) mapped to each SOM node</span>

<span class="comment">% ====== Plot marks based on size ======</span>
figure(2);                                             <span class="comment">% Open figure</span>

colormap(1-gray)                                       <span class="comment">% Set colormap to inverted grayscale for better contrast</span>
som_show(sMap, <span class="string">'norm'</span>, <span class="string">'d'</span>, <span class="string">'umat'</span>, <span class="string">'all'</span>);            <span class="comment">% Display only the U-Matrix (distance map) of the SOM</span>
som_show_add(<span class="string">'hit'</span>, hit, ...                           <span class="comment">% Overlay hit markers on the SOM map</span>
             <span class="string">'MarkerColor'</span>, <span class="string">'r'</span>, <span class="string">'MarkerSize'</span>, 0.5);   <span class="comment">% Set marker color to red and marker size to 0.5</span>
title(<span class="string">'SOM Hits Sized Marks'</span>);                         <span class="comment">% Add a title to the plot</span>
saveas(gcf, <span class="string">'MeHg_SOM_hit_mark.png'</span>);       <span class="comment">% Save as PNG</span>

<span class="comment">% ====== Plot numeric hit counts ======</span>
figure(3);                                                                   <span class="comment">% Open figure</span>

colormap(1-gray)                                                             <span class="comment">% Set colormap to inverted grayscale for better contrast</span>
som_show(sMap, <span class="string">'norm'</span>, <span class="string">'d'</span>, <span class="string">'umat'</span>, <span class="string">'all'</span>);                                  <span class="comment">% Display only the U-Matrix (distance map) of the SOM</span>
pos = som_unit_coords(sMap);                                                 <span class="comment">% Get the (x, y) coordinates of all SOM units (neurons)</span>

x_offset = 0.9;                                                              <span class="comment">% Horizontal offset</span>
y_offset = 0.9;                                                              <span class="comment">% Vertical offset</span>
pos(:,1) = pos(:,1) * sqrt(3)/1.73;                                          <span class="comment">% Horizontal scale</span>
pos(:,2) = pos(:,2) * 1.155;                                                 <span class="comment">% Vertical scale</span>

<span class="keyword">for</span> i = 1:length(hit)                                                        <span class="comment">% Loop through each SOM unit</span>
    <span class="keyword">if</span> hit(i) &gt; 0                                                            <span class="comment">% Only label units that have one or more hits</span>
        text(pos(i,1) + x_offset, pos(i,2) + y_offset, num2str(hit(i)), ...  <span class="comment">% Place text near the unit showing the hit count</span>
              <span class="string">'Color'</span>, <span class="string">'r'</span>, <span class="string">'FontSize'</span>, 10, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);           <span class="comment">% Set text color, size, and bold font for visibility</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
title(<span class="string">'SOM Hit Numbers'</span>);                                                    <span class="comment">% Add a title to the plot</span>
saveas(gcf, <span class="string">'MeHg_SOM_hit_number.png'</span>);       <span class="comment">% Save as PNG</span>


<span class="comment">% ====== Plot regional labels ======</span>
figure(4);                                                                   <span class="comment">% Open figure</span>

textdata = csv2cell(<span class="string">'Rosati_Data_Model_Output/data_ancillary_MeHg.csv'</span>);     <span class="comment">% Read CSV file into a cell array</span>
RegionalLabels = textdata(2:end,5);                                          <span class="comment">% Extract the regional labels from the 5th column (skip header row)</span>
sData.labels = RegionalLabels;                                               <span class="comment">% Initialize your SOM data structure labels with regional labels</span>
map_keys   = {<span class="string">'SAD'</span>,<span class="string">'TYR2'</span>,<span class="string">'ION1_2'</span>,<span class="string">'LEV'</span>,<span class="string">'SWM'</span>,<span class="string">'ALB'</span>,<span class="string">'NWM'</span>,<span class="string">'ION3'</span>,<span class="string">'TYR1'</span>};  <span class="comment">% Original CSV labels</span>
map_values = {  <span class="string">'D'</span>,   <span class="string">'T'</span>,     <span class="string">'I'</span>,  <span class="string">'L'</span>,  <span class="string">'S'</span>,  <span class="string">'A'</span>,  <span class="string">'N'</span>,   <span class="string">'I'</span>,   <span class="string">'T'</span>};  <span class="comment">% Corresponding single-letter codes</span>
mappedLabels = RegionalLabels;                                               <span class="comment">% Initialize mappedLabels with the original labels</span>

<span class="comment">% Loop through each key in map_keys</span>
<span class="keyword">for</span> k = 1:length(map_keys)
    idx = strcmp(RegionalLabels, map_keys{k});                               <span class="comment">% Find all occurrences of the current key in RegionalLabels</span>
    mappedLabels(idx) = map_values(k);                                       <span class="comment">% Replace matching labels with the corresponding single-letter code</span>
<span class="keyword">end</span>

sData.labels = mappedLabels;                                                 <span class="comment">% Assign the mapped labels to the SOM data structure</span>
sMap = som_autolabel(sMap, sData, <span class="string">'vote'</span>);                                   <span class="comment">% Automatically label the SOM map using the mapped labels</span>
colormap(1-gray)                                                             <span class="comment">% Set colormap to grayscale (1-gray inverts the grayscale)</span>
som_show(sMap,<span class="string">'norm'</span>,<span class="string">'d'</span>, <span class="string">'umat'</span>, <span class="string">'all'</span>);                                    <span class="comment">% Display the SOM map with normalized distances</span>
som_show_add(<span class="string">'label'</span>, sMap, <span class="string">'TextSize'</span>, 10, <span class="string">'TextColor'</span>, <span class="string">'r'</span>);               <span class="comment">% Add labels normally</span>
hText = findall(gca, <span class="string">'Type'</span>, <span class="string">'text'</span>);                                        <span class="comment">% Get all text objects in the current axes</span>
set(hText, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);                                            <span class="comment">% Set font weight to bold</span>
title(<span class="string">'SOM Regional Labels'</span>);                                                <span class="comment">% Add a title to the plot</span>
saveas(gcf, <span class="string">'MeHg_SOM_hit_region.png'</span>);       <span class="comment">% Save as PNG</span>
</pre>

<pre class="oct-code-output">error: 'sMap' undefined near line 1, column 16
	in:

hit = som_hits(sMap, sData);                     % Compute the number of data samples (hits) mapped to each SOM node

% ====== Plot marks based on size ======
figure(2);                                             % Open figure

colormap(1-gray)                                       % Set colormap to inverted grayscale for better contrast
som_show(sMap, 'norm', 'd', 'umat', 'all');            % Display only the U-Matrix (distance map) of the SOM
som_show_add('hit', hit, ...                           % Overlay hit markers on the SOM map
             'MarkerColor', 'r', 'MarkerSize', 0.5);   % Set marker color to red and marker size to 0.5
title('SOM Hits Sized Marks');                         % Add a title to the plot
saveas(gcf, 'MeHg_SOM_hit_mark.png');       % Save as PNG

% ====== Plot numeric hit counts ======
figure(3);                                                                   % Open figure

colormap(1-gray)                                                             % Set colormap to inverted grayscale for better contrast
som_show(sMap, 'norm', 'd', 'umat', 'all');                                  % Display only the U-Matrix (distance map) of the SOM
pos = som_unit_coords(sMap);                                                 % Get the (x, y) coordinates of all SOM units (neurons)

x_offset = 0.9;                                                              % Horizontal offset
y_offset = 0.9;                                                              % Vertical offset
pos(:,1) = pos(:,1) * sqrt(3)/1.73;                                          % Horizontal scale
pos(:,2) = pos(:,2) * 1.155;                                                 % Vertical scale

for i = 1:length(hit)                                                        % Loop through each SOM unit
    if hit(i) &gt; 0                                                            % Only label units that have one or more hits
        text(pos(i,1) + x_offset, pos(i,2) + y_offset, num2str(hit(i)), ...  % Place text near the unit showing the hit count
              'Color', 'r', 'FontSize', 10, 'FontWeight', 'bold');           % Set text color, size, and bold font for visibility
    end
end
title('SOM Hit Numbers');                                                    % Add a title to the plot
saveas(gcf, 'MeHg_SOM_hit_number.png');       % Save as PNG


% ====== Plot regional labels ======
figure(4);                                                                   % Open figure

textdata = csv2cell('Rosati_Data_Model_Output/data_ancillary_MeHg.csv');     % Read CSV file into a cell array
RegionalLabels = textdata(2:end,5);                                          % Extract the regional labels from the 5th column (skip header row)
sData.labels = RegionalLabels;                                               % Initialize your SOM data structure labels with regional labels
map_keys   = {'SAD','TYR2','ION1_2','LEV','SWM','ALB','NWM','ION3','TYR1'};  % Original CSV labels
map_values = {  'D',   'T',     'I',  'L',  'S',  'A',  'N',   'I',   'T'};  % Corresponding single-letter codes
mappedLabels = RegionalLabels;                                               % Initialize mappedLabels with the original labels

% Loop through each key in map_keys
for k = 1:length(map_keys)
    idx = strcmp(RegionalLabels, map_keys{k});                               % Find all occurrences of the current key in RegionalLabels
    mappedLabels(idx) = map_values(k);                                       % Replace matching labels with the corresponding single-letter code
end

sData.labels = mappedLabels;                                                 % Assign the mapped labels to the SOM data structure
sMap = som_autolabel(sMap, sData, 'vote');                                   % Automatically label the SOM map using the mapped labels
colormap(1-gray)                                                             % Set colormap to grayscale (1-gray inverts the grayscale)
som_show(sMap,'norm','d', 'umat', 'all');                                    % Display the SOM map with normalized distances
som_show_add('label', sMap, 'TextSize', 10, 'TextColor', 'r');               % Add labels normally
hText = findall(gca, 'Type', 'text');                                        % Get all text objects in the current axes
set(hText, 'FontWeight', 'bold');                                            % Set font weight to bold
title('SOM Regional Labels');                                                % Add a title to the plot
saveas(gcf, 'MeHg_SOM_hit_region.png');       % Save as PNG

</pre>
<h2><a id="node22">===================== 9. Map SOM units back to coordinates =====================    % NOT USEFUL OUTPUT PRODUCED</a></h2>
<pre class="oct-code"><span class="comment">%figure(5);                                                                            % Open figure</span>
<span class="comment">%</span>
<span class="comment">%top = 100                                                                             % Select the top of the water column where to find the sample</span>
<span class="comment">%bottom = 120                                                                          % Select the bottom of the water column where to find the sample</span>
<span class="comment">%surface_idx = dataset(:,8) &gt;= top &amp; dataset(:,8) &lt;= bottom;                           % Logical filter index for depths &gt;# and &lt;=#</span>
<span class="comment">%coords_surface = dataset(surface_idx, [4 3]);                                         % Extract Longitude (column 4) and Latitude (column 3) for surface points</span>
<span class="comment">%bmus_surface = bmus(surface_idx);                                                     % BMU values corresponding to surface points</span>

<span class="comment">%scatter(coords_surface(:,1), coords_surface(:,2), 50, bmus_surface, 'filled');        % Scatter plot of surface points colored by BMU; 50 = marker size, 'filled' = filled circles</span>
<span class="comment">%axis equal;                                                                           % Ensure x and y axes have the same scale</span>
<span class="comment">%xlim([-5 30]);                                                                        % Fixed longitude range (x-axis) from -5 to 30</span>
<span class="comment">%ylim([35 45]);                                                                        % Fixed latitude range (y-axis) from 35 to 45</span>
<span class="comment">%colorbar;                                                                             % Show colorbar representing BMU indices</span>
<span class="comment">%xlabel('Longitude');                                                                  % Label x-axis</span>
<span class="comment">%ylabel('Latitude');                                                                   % Label y-axis</span>
<span class="comment">%title(sprintf('SOM Cluster Mediterranean Map - Depth %.1f to %.1f m', top, bottom));  % Add a title to the plot</span>
<span class="comment">%set(gcf, 'Position', [100, 100, 800, 250]);                                           % Resize figure window for better clarity</span>

clear map_keys map_values mappedLabels x_offset y_offset     <span class="comment">% Clear temporary variables from workspace</span>
</pre>
<h2><a id="node23">============================================================</a></h2><h2><a id="node24">================== Cossarini's Model Data ==================</a></h2><h2><a id="node25">============================================================</a></h2>
<pre class="oct-code">idx_list = [1, 5, 8, 11, 14, 16, 26]      <span class="comment">% Loop over the slice indexes at wich you want to make the plot</span>
</pre>

<pre class="oct-code-output">idx_list =
 
    1    5    8   11   14   16   26
 
</pre>
<h2><a id="node26">===================== 1. Initialise =====================</a></h2>
<pre class="oct-code">baseFolder = <span class="string">'Cossarini_Model_Output'</span>;                                             <span class="comment">% Base folder containing NetCDF files</span>
fileNames = { ...                                                                  <span class="comment">% List of NetCDF file names to process</span>
    <span class="string">'20200101_y-CMCC--PSAL-MFSe3r1-MED-b20220901_re-sv01.00.nc'</span>, ...
    <span class="string">'20200101_y-CMCC--TEMP-MFSe3r1-MED-b20220901_re-sv01.00.nc'</span>, ...
    <span class="string">'20200101_y-OGS--BIOL-MedBFM3-MED-b20221120_re-sv05.00.nc'</span> ...
};

files = cellfun(@(f) fullfile(baseFolder, f), fileNames, <span class="string">'UniformOutput'</span>, false);  <span class="comment">% Create full paths for all files</span>
allVarNames = cell(1, numel(files));                                               <span class="comment">% Initialize cell array to store variable names for each file</span>

<span class="keyword">for</span> f = 1:numel(files)                                                             <span class="comment">% Loop over each NetCDF file</span>
    ncid = netcdf.open(files{f}, <span class="string">'NC_NOWRITE'</span>);                                    <span class="comment">% Open file in read-only mode</span>
    [~, nvars, ~, ~] = netcdf.inq(ncid);                                           <span class="comment">% Get the number of variables in the file</span>
    varnames = cell(1, nvars);                                                     <span class="comment">% Initialize cell array for variable names</span>
    <span class="keyword">for</span> i = 0:nvars-1                                                              <span class="comment">% Loop through all variables</span>
        [varname, ~, ~, ~] = netcdf.inqVar(ncid, i);                               <span class="comment">% Get the variable name</span>
        varnames{i+1} = varname;                                                   <span class="comment">% Store in the cell array (MATLAB/Octave indexing starts at 1)</span>
    <span class="keyword">end</span>

    allVarNames{f} = varnames;                                                     <span class="comment">% Store variable names for this file</span>
    netcdf.close(ncid);                                                            <span class="comment">% Close the NetCDF file</span>
<span class="keyword">end</span>

<span class="comment">% Display variable names for each file</span>
<span class="keyword">for</span> f = 1:numel(files)                                                             <span class="comment">% Loop over each file</span>
    fprintf(<span class="string">'Variables in file %d:\n'</span>, f);                                         <span class="comment">% Print file index</span>
    disp(allVarNames{f});                                                          <span class="comment">% Display the variable names</span>
<span class="keyword">end</span>

clear f i ncid nvars varname varnames                                              <span class="comment">% Clear temporary variables from workspace</span>
</pre>

<pre class="oct-code-output">Variables in file 1:
{
  [1,1] = so
  [1,2] = depth
  [1,3] = lon
  [1,4] = lat
  [1,5] = time
}
Variables in file 2:
{
  [1,1] = thetao
  [1,2] = depth
  [1,3] = lon
  [1,4] = lat
  [1,5] = time
  [1,6] = bottomT
}
Variables in file 3:
{
  [1,1] = time
  [1,2] = depth
  [1,3] = latitude
  [1,4] = longitude
  [1,5] = o2
  [1,6] = nppv
}
</pre>
<h2><a id="node27">===================== 2. Load .nc files =====================</a></h2>
<pre class="oct-code">ncid = netcdf.open(files{1}, <span class="string">'NC_NOWRITE'</span>);      <span class="comment">% Open first NetCDF file (PSAL) in read-only mode</span>
varid = netcdf.inqVarID(ncid, <span class="string">'so'</span>);             <span class="comment">% Get variable ID for 'so' (salinity)</span>
dataso = netcdf.getVar(ncid, varid);             <span class="comment">% Read the 'so' variable data into MATLAB/Octave</span>
netcdf.close(ncid);                              <span class="comment">% Close the first NetCDF file</span>

ncid = netcdf.open(files{2}, <span class="string">'NC_NOWRITE'</span>);      <span class="comment">% Open second NetCDF file (TEMP) in read-only mode</span>
varid = netcdf.inqVarID(ncid, <span class="string">'thetao'</span>);         <span class="comment">% Get variable ID for 'thetao' (temperature)</span>
dataT = netcdf.getVar(ncid, varid);              <span class="comment">% Read the 'thetao' variable data</span>
netcdf.close(ncid);                              <span class="comment">% Close the second NetCDF file</span>

ncid = netcdf.open(files{3}, <span class="string">'NC_NOWRITE'</span>);      <span class="comment">% Open third NetCDF file (BIOL) in read-only mode</span>
varid = netcdf.inqVarID(ncid, <span class="string">'o2'</span>);             <span class="comment">% Get variable ID for 'o2' (oxygen)</span>
dataO = netcdf.getVar(ncid, varid);              <span class="comment">% Read the 'o2' variable data</span>
netcdf.close(ncid);                              <span class="comment">% Close the third NetCDF file</span>

clear ncid varid                                 <span class="comment">% Clear temporary NetCDF handles from workspace</span>

dataT = dataT(12:end, :, 1:125);                                    <span class="comment">% Subset temperature data: skip first 11 rows, keep all columns, limit to first 125 depth levels</span>
dataso = dataso(12:end, :, 1:125);                                  <span class="comment">% Subset salinity data similarly</span>


<span class="keyword">for</span> idx = idx_list
    <span class="comment">%% ===================== 3. Process the matrix =====================</span>

    slice   = [1, 5, 8, 11, 14, 16, 26];                                <span class="comment">% Depth indices corresponding to available depths</span>
    dpths_m = [1.0182, 10.537, 19.398, 29.886, 42.145, 51.38, 112.25];  <span class="comment">% Depth values in meters</span>
    pos = find(slice == idx);                                           <span class="comment">% Find the position of the selected idx in the slice array</span>
    dpth_m = dpths_m(pos);                                              <span class="comment">% Selected depth</span>

    slicedataT  = dataT(:, :, idx);                                     <span class="comment">% Extract temperature at selected depth(s)</span>
    slicedataO  = dataO(:, :, idx);                                     <span class="comment">% Extract oxygen at selected depth(s)</span>
    slicedataso = dataso(:, :, idx);                                    <span class="comment">% Extract salinity at selected depth(s)</span>

    slicedataT  = slicedataT(:);                                        <span class="comment">% Flatten temperature matrix into a column vector</span>
    slicedataO  = slicedataO(:);                                        <span class="comment">% Flatten oxygen matrix into a column vector</span>
    slicedataso = slicedataso(:);                                       <span class="comment">% Flatten salinity matrix into a column vector</span>

    slicedataT(slicedataT == 1e+20) = [];                               <span class="comment">% Remove fill/missing values from temperature</span>
    slicedataO(slicedataO == 1e+20) = [];                               <span class="comment">% Remove fill/missing values from oxygen</span>
    slicedataso(slicedataso == 1e+20) = [];                             <span class="comment">% Remove fill/missing values from salinity</span>

    slicedata = cat(2, slicedataT, slicedataso, slicedataO);            <span class="comment">% Concatenate temperature, salinity, and oxygen into one data matrix</span>


    <span class="comment">%% ===================== 4. SOM commands=====================</span>
    sData_cossarini = som_data_struct(slicedata(1:end,1:3), <span class="string">'name'</span>, <span class="string">'Cossarini Dataset'</span>, <span class="string">'comp_names'</span>, {<span class="string">'Temp'</span>,<span class="string">'Sal'</span>,<span class="string">'O2_uM'</span>}); <span class="comment">% Structure</span>
    clear sData_cossarini_newT sData_cossarini_newSO sData_cossarini_newO sData_cossarini_new                                   <span class="comment">% Clear variables before usage</span>
    sData_cossarini_newT(:,1)  = som_normalize(sData_cossarini.data(:,1),sData.comp_norm{2});                                   <span class="comment">% Normalization temperature</span>
    sData_cossarini_newSO(:,1) = som_normalize(sData_cossarini.data(:,2),sData.comp_norm{3});                                   <span class="comment">% Normalization salinity</span>
    sData_cossarini_newO(:,1)  = som_normalize(sData_cossarini.data(:,3),sData.comp_norm{4});                                   <span class="comment">% Normalization oxygen</span>


    <span class="comment">%% ===================== 5. BEST-MATCHING UNITS (BMUs) =====================</span>
    nRows = size(sData_cossarini_newT, 1);                                               <span class="comment">% Number of rows in temperature dataset</span>
    nan_col = nan(nRows, 1);                                                             <span class="comment">% Create a column of NaN values to align dataset dimensions</span>
    sData_cossarini_new = [nan_col, sData_cossarini_newT, sData_cossarini_newSO, sData_cossarini_newO];  <span class="comment">% Combine NaN column + Temp + Salinity + Oxygen into one matrix</span>

    nRowssliced = size(slicedata, 1);                                                    <span class="comment">% Number of rows in sliced (depth-specific) dataset</span>
    nan_colsliced = nan(nRowssliced, 1);                                                 <span class="comment">% Create a column of NaN values for sliced dataset</span>
    sliced_denormalize = cat(2, nan_colsliced, slicedata);                               <span class="comment">% Concatenate NaN column and sliced data to match SOM input format</span>

    bmus_surfaceGP = som_bmus(sMap, sData_cossarini_new);                                <span class="comment">% Find Best Matching Units (BMUs) for surface dataset</span>
    bmus_surfaceGP_denorm = som_bmus(sMap, sliced_denormalize);                          <span class="comment">% Find BMUs for denormalized sliced dataset</span>



    <span class="comment">%% =====================================================</span>
    <span class="comment">%% ===== PLOTS ===== PLOTS ===== PLOTS ===== PLOTS =====</span>
    <span class="comment">%% =====================================================</span>

    <span class="comment">%% ===================== 6. Hit Plots =====================</span>
    hit_surfaceGP = som_hits(sMap, sData_cossarini_new);                                   <span class="comment">% Compute the number of data samples (hits) mapped to each SOM node</span>

    <span class="comment">% ====== Plot numeric hit counts ======</span>
    figure(6);                                                                             <span class="comment">% Open figure</span>
    colormap(1-gray)                                                                       <span class="comment">% Set colormap to inverted grayscale for better contrast</span>
    som_show(sMap, <span class="string">'norm'</span>, <span class="string">'d'</span>, <span class="string">'umat'</span>, <span class="string">'all'</span>);                                            <span class="comment">% Display only the U-Matrix (distance map) of the SOM</span>
    pos = som_unit_coords(sMap);                                                           <span class="comment">% Get the (x, y) coordinates of all SOM units (neurons)</span>

    x_offset = 0.9;                                                                        <span class="comment">% Horizontal offset</span>
    y_offset = 0.9;                                                                        <span class="comment">% Vertical offset</span>
    pos(:,1) = pos(:,1) * sqrt(3)/1.73;                                                    <span class="comment">% Horizontal scale</span>
    pos(:,2) = pos(:,2) * 1.155;                                                           <span class="comment">% Vertical scale</span>

    <span class="keyword">for</span> i = 1:length(hit_surfaceGP)                                                        <span class="comment">% Loop through each SOM unit</span>
        <span class="keyword">if</span> hit_surfaceGP(i) &gt; 0                                                            <span class="comment">% Only label units that have one or more hits</span>
            text(pos(i,1) + x_offset, pos(i,2) + y_offset, num2str(hit_surfaceGP(i)), ...  <span class="comment">% Place text near the unit showing the hit count</span>
                  <span class="string">'Color'</span>, <span class="string">'r'</span>, <span class="string">'FontSize'</span>, 6, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);                      <span class="comment">% Set text color, size, and bold font for visibility</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    title(sprintf(<span class="string">'SOM Hit Numbers Slice at -%.1f m'</span>, dpth_m));                            <span class="comment">% Add a title to the plot</span>
    filename = sprintf(<span class="string">'MeHg_SOM_Hit_Numbers_Slice_at_-%.1f_m.png'</span>, dpth_m);               <span class="comment">% Create filename based on title</span>
    saveas(gcf, filename);                                                                 <span class="comment">% Save current figure as PNG</span>

    clear i k     <span class="comment">% Clear temporary variables from workspace</span>
<span class="keyword">end</span></pre>

<pre class="oct-code-output">error: 'som_data_struct' undefined near line 25, column 23
	in:

ncid = netcdf.open(files{1}, 'NC_NOWRITE');      % Open first NetCDF file (PSAL) in read-only mode
varid = netcdf.inqVarID(ncid, 'so');             % Get variable ID for 'so' (salinity)
dataso = netcdf.getVar(ncid, varid);             % Read the 'so' variable data into MATLAB/Octave
netcdf.close(ncid);                              % Close the first NetCDF file

ncid = netcdf.open(files{2}, 'NC_NOWRITE');      % Open second NetCDF file (TEMP) in read-only mode
varid = netcdf.inqVarID(ncid, 'thetao');         % Get variable ID for 'thetao' (temperature)
dataT = netcdf.getVar(ncid, varid);              % Read the 'thetao' variable data
netcdf.close(ncid);                              % Close the second NetCDF file

ncid = netcdf.open(files{3}, 'NC_NOWRITE');      % Open third NetCDF file (BIOL) in read-only mode
varid = netcdf.inqVarID(ncid, 'o2');             % Get variable ID for 'o2' (oxygen)
dataO = netcdf.getVar(ncid, varid);              % Read the 'o2' variable data
netcdf.close(ncid);                              % Close the third NetCDF file

clear ncid varid                                 % Clear temporary NetCDF handles from workspace

dataT = dataT(12:end, :, 1:125);                                    % Subset temperature data: skip first 11 rows, keep all columns, limit to first 125 depth levels
dataso = dataso(12:end, :, 1:125);                                  % Subset salinity data similarly


for idx = idx_list
    %% ===================== 3. Process the matrix =====================

    slice   = [1, 5, 8, 11, 14, 16, 26];                                % Depth indices corresponding to available depths
    dpths_m = [1.0182, 10.537, 19.398, 29.886, 42.145, 51.38, 112.25];  % Depth values in meters
    pos = find(slice == idx);                                           % Find the position of the selected idx in the slice array
    dpth_m = dpths_m(pos);                                              % Selected depth

    slicedataT  = dataT(:, :, idx);                                     % Extract temperature at selected depth(s)
    slicedataO  = dataO(:, :, idx);                                     % Extract oxygen at selected depth(s)
    slicedataso = dataso(:, :, idx);                                    % Extract salinity at selected depth(s)

    slicedataT  = slicedataT(:);                                        % Flatten temperature matrix into a column vector
    slicedataO  = slicedataO(:);                                        % Flatten oxygen matrix into a column vector
    slicedataso = slicedataso(:);                                       % Flatten salinity matrix into a column vector

    slicedataT(slicedataT == 1e+20) = [];                               % Remove fill/missing values from temperature
    slicedataO(slicedataO == 1e+20) = [];                               % Remove fill/missing values from oxygen
    slicedataso(slicedataso == 1e+20) = [];                             % Remove fill/missing values from salinity

    slicedata = cat(2, slicedataT, slicedataso, slicedataO);            % Concatenate temperature, salinity, and oxygen into one data matrix


    %% ===================== 4. SOM commands=====================
    sData_cossarini = som_data_struct(slicedata(1:end,1:3), 'name', 'Cossarini Dataset', 'comp_names', {'Temp','Sal','O2_uM'}); % Structure
    clear sData_cossarini_newT sData_cossarini_newSO sData_cossarini_newO sData_cossarini_new                                   % Clear variables before usage
    sData_cossarini_newT(:,1)  = som_normalize(sData_cossarini.data(:,1),sData.comp_norm{2});                                   % Normalization temperature
    sData_cossarini_newSO(:,1) = som_normalize(sData_cossarini.data(:,2),sData.comp_norm{3});                                   % Normalization salinity
    sData_cossarini_newO(:,1)  = som_normalize(sData_cossarini.data(:,3),sData.comp_norm{4});                                   % Normalization oxygen


    %% ===================== 5. BEST-MATCHING UNITS (BMUs) =====================
    nRows = size(sData_cossarini_newT, 1);                                               % Number of rows in temperature dataset
    nan_col = nan(nRows, 1);                                                             % Create a column of NaN values to align dataset dimensions
    sData_cossarini_new = [nan_col, sData_cossarini_newT, sData_cossarini_newSO, sData_cossarini_newO];  % Combine NaN column + Temp + Salinity + Oxygen into one matrix

    nRowssliced = size(slicedata, 1);                                                    % Number of rows in sliced (depth-specific) dataset
    nan_colsliced = nan(nRowssliced, 1);                                                 % Create a column of NaN values for sliced dataset
    sliced_denormalize = cat(2, nan_colsliced, slicedata);                               % Concatenate NaN column and sliced data to match SOM input format

    bmus_surfaceGP = som_bmus(sMap, sData_cossarini_new);                                % Find Best Matching Units (BMUs) for surface dataset
    bmus_surfaceGP_denorm = som_bmus(sMap, sliced_denormalize);                          % Find BMUs for denormalized sliced dataset



    %% =====================================================
    %% ===== PLOTS ===== PLOTS ===== PLOTS ===== PLOTS =====
    %% =====================================================

    %% ===================== 6. Hit Plots =====================
    hit_surfaceGP = som_hits(sMap, sData_cossarini_new);                                   % Compute the number of data samples (hits) mapped to each SOM node

    % ====== Plot numeric hit counts ======
    figure(6);                                                                             % Open figure
    colormap(1-gray)                                                                       % Set colormap to inverted grayscale for better contrast
    som_show(sMap, 'norm', 'd', 'umat', 'all');                                            % Display only the U-Matrix (distance map) of the SOM
    pos = som_unit_coords(sMap);                                                           % Get the (x, y) coordinates of all SOM units (neurons)

    x_offset = 0.9;                                                                        % Horizontal offset
    y_offset = 0.9;                                                                        % Vertical offset
    pos(:,1) = pos(:,1) * sqrt(3)/1.73;                                                    % Horizontal scale
    pos(:,2) = pos(:,2) * 1.155;                                                           % Vertical scale

    for i = 1:length(hit_surfaceGP)                                                        % Loop through each SOM unit
        if hit_surfaceGP(i) &gt; 0                                                            % Only label units that have one or more hits
            text(pos(i,1) + x_offset, pos(i,2) + y_offset, num2str(hit_surfaceGP(i)), ...  % Place text near the unit showing the hit count
                  'Color', 'r', 'FontSize', 6, 'FontWeight', 'bold');                      % Set text color, size, and bold font for visibility
        end
    end
    title(sprintf('SOM Hit Numbers Slice at -%.1f m', dpth_m));                            % Add a title to the plot
    filename = sprintf('MeHg_SOM_Hit_Numbers_Slice_at_-%.1f_m.png', dpth_m);               % Create filename based on title
    saveas(gcf, filename);                                                                 % Save current figure as PNG

    clear i k     % Clear temporary variables from workspace
end



</pre>
<h2><a id="node28">=============================================================</a></h2><h2><a id="node29">============= SAVING LOOP FOR MULTIPLE Z-LEVELS =============</a></h2><h2><a id="node30">=============================================================</a></h2>
<pre class="oct-code">z_level = [1, 5, 8, 11, 14, 16, 26];                                <span class="comment">% Define indices of depth slices to process</span>
slice   = [z_level];                                                <span class="comment">% Copy z_level into slice variable</span>
dpths_m = [1.0182, 10.537, 19.398, 29.886, 42.145, 51.38, 112.25];  <span class="comment">% Depths in meters corresponding to indices</span>
</pre>
<h2><a id="node31">===================== 1. Initialise =====================</a></h2>
<pre class="oct-code">baseFolder = <span class="string">'Cossarini_Model_Output'</span>;                                               <span class="comment">% Folder containing data files</span>
fileNames = { ...                                                                    <span class="comment">% List of .nc filenames</span>
    <span class="string">'20200101_y-CMCC--PSAL-MFSe3r1-MED-b20220901_re-sv01.00.nc'</span>, ...                 <span class="comment">% Salinity</span>
    <span class="string">'20200101_y-CMCC--TEMP-MFSe3r1-MED-b20220901_re-sv01.00.nc'</span>, ...                 <span class="comment">% Temperature</span>
    <span class="string">'20200101_y-OGS--BIOL-MedBFM3-MED-b20221120_re-sv05.00.nc'</span> ...                   <span class="comment">% Oxygen</span>
};
files = cellfun(@(f) fullfile(baseFolder, f), fileNames, <span class="string">'UniformOutput'</span>, false);    <span class="comment">% Create full paths for files</span>
</pre>
<h2><a id="node32">=================== 2. Load .nc files ===================</a></h2>
<p>Load once outside the loop to save time</p>

<pre class="oct-code">ncid = netcdf.open(files{1}, <span class="string">'NC_NOWRITE'</span>);                   <span class="comment">% Open first file (salinity)</span>
dataso = netcdf.getVar(ncid, netcdf.inqVarID(ncid, <span class="string">'so'</span>));    <span class="comment">% Read salinity variable</span>
netcdf.close(ncid);                                           <span class="comment">% Close the file</span>
ncid = netcdf.open(files{2}, <span class="string">'NC_NOWRITE'</span>);                   <span class="comment">% Open second file (temperature)</span>
dataT = netcdf.getVar(ncid, netcdf.inqVarID(ncid, <span class="string">'thetao'</span>)); <span class="comment">% Read temperature variable</span>
netcdf.close(ncid);
ncid = netcdf.open(files{3}, <span class="string">'NC_NOWRITE'</span>);                   <span class="comment">% Open third file (oxygen)</span>
dataO = netcdf.getVar(ncid, netcdf.inqVarID(ncid, <span class="string">'o2'</span>));     <span class="comment">% Read oxygen variable</span>
netcdf.close(ncid);

ncid = netcdf.open(files{1}, <span class="string">'NC_NOWRITE'</span>);                   <span class="comment">% Re-open first file to get latitude</span>
datalat = netcdf.getVar(ncid, netcdf.inqVarID(ncid, <span class="string">'lat'</span>));  <span class="comment">% Read latitude</span>
netcdf.close(ncid);
ncid = netcdf.open(files{1}, <span class="string">'NC_NOWRITE'</span>);                   <span class="comment">% Re-open first file to get longitude</span>
datalon = netcdf.getVar(ncid, netcdf.inqVarID(ncid, <span class="string">'lon'</span>));  <span class="comment">% Read longitude</span>
netcdf.close(ncid);
ncid = netcdf.open(files{1}, <span class="string">'NC_NOWRITE'</span>);                   <span class="comment">% Re-open first file to get depth</span>
varid = netcdf.inqVarID(ncid, <span class="string">'depth'</span>);                       <span class="comment">% Get variable ID for depth</span>
datadepth = netcdf.getVar(ncid, varid);                       <span class="comment">% Read depth variable</span>

<span class="comment">% Subset to region/depth range</span>
dataT = dataT(12:end, :, 1:125);                   <span class="comment">% Keep subset of temperature data</span>
dataso = dataso(12:end, :, 1:125);                 <span class="comment">% Keep subset of salinity data</span>
datalon = datalon(12:end);                         <span class="comment">% Subset longitude</span>

<span class="comment">% Create coordinate indexing</span>
[lat_grid, lon_grid] = meshgrid(datalat,datalon);  <span class="comment">% Create 2D grid of lat/lon</span>
flat_lat = lat_grid(:);                            <span class="comment">% Flatten latitude grid</span>
flat_lon = lon_grid(:);                            <span class="comment">% Flatten longitude grid</span>
latlon_matrix = [flat_lat, flat_lon];              <span class="comment">% Combine lat/lon into single matrix</span>
</pre>
<h2><a id="node33">===================== 3. Loop over depth slices =====================</a></h2>
<pre class="oct-code"><span class="keyword">for</span> n = 1:length(slice)                            <span class="comment">% Loop over each depth slice</span>

    <span class="comment">%% ========== Data Preparation ===============</span>
    latlon_sliced = latlon_matrix;                 <span class="comment">% Copy lat/lon for current slice</span>
    idx = slice(n);                                <span class="comment">% Current depth index</span>
    dpth_m = dpths_m(n);                           <span class="comment">% Current depth in meters</span>

    fprintf(<span class="string">'\nProcessing depth index %d (%.1f m)...\n'</span>, idx, dpth_m);  <span class="comment">% Print processing info</span>

    slicedataT  = dataT(:, :, idx);                           <span class="comment">% Extract temperature at current depth</span>
    slicedataO  = dataO(:, :, idx);                           <span class="comment">% Extract oxygen at current depth</span>
    slicedataso = dataso(:, :, idx);                          <span class="comment">% Extract salinity at current depth</span>

    slicedataT  = slicedataT(:);                              <span class="comment">% Flatten temperature</span>
    slicedataO  = slicedataO(:);                              <span class="comment">% Flatten oxygen</span>
    slicedataso = slicedataso(:);                             <span class="comment">% Flatten salinity</span>

    latlon_sliced(slicedataT == 1e+20, :) = [];               <span class="comment">% Remove lat/lon where temperature is missing</span>
    slicedataT(slicedataT == 1e+20) = [];                     <span class="comment">% Remove missing temperature values</span>
    slicedataO(slicedataO == 1e+20) = [];                     <span class="comment">% Remove missing oxygen values</span>
    slicedataso(slicedataso == 1e+20) = [];                   <span class="comment">% Remove missing salinity values</span>

    slicedata = cat(2, slicedataT, slicedataso, slicedataO);  <span class="comment">% Combine T, Sal, O2 into one matrix</span>

    <span class="comment">%% ========== Data Elaboration ===============</span>
    sData_cossarini = som_data_struct(slicedata, <span class="string">'name'</span>, <span class="string">'Cossarini Dataset'</span>, <span class="string">'comp_names'</span>, {<span class="string">'Temp'</span>,<span class="string">'Sal'</span>,<span class="string">'O2_uM'</span>});  <span class="comment">% Create SOM data struct</span>

    sData_cossarini_newT  = som_normalize(sData_cossarini.data(:,1), sData.comp_norm{2});  <span class="comment">% Normalize temperature</span>
    sData_cossarini_newSO = som_normalize(sData_cossarini.data(:,2), sData.comp_norm{3});  <span class="comment">% Normalize salinity</span>
    sData_cossarini_newO  = som_normalize(sData_cossarini.data(:,3), sData.comp_norm{4});  <span class="comment">% Normalize oxygen</span>

    nRows = size(sData_cossarini_newT, 1);                                                               <span class="comment">% Number of rows in normalized temperature</span>
    nan_col = nan(nRows, 1);                                                                             <span class="comment">% Create column of NaNs for alignment</span>
    sData_cossarini_new = [nan_col, sData_cossarini_newT, sData_cossarini_newSO, sData_cossarini_newO];  <span class="comment">% Combine NaN + normalized data</span>
    bmus_surfaceGP = som_bmus(sMap, sData_cossarini_new);                                                <span class="comment">% Compute BMUs (best matching units)</span>
    hg_codebook = sMap.codebook(bmus_surfaceGP, 1);                                                      <span class="comment">% Extract corresponding codebook entries</span>
    hg_codebook_denorm = som_denormalize(hg_codebook, sMap.comp_norm(1));                                <span class="comment">% Denormalize BMU values</span>

    nRows = size(sData_cossarini.data, 1);                             <span class="comment">% Number of rows in original data</span>
    nan_col = nan(nRows, 1);                                           <span class="comment">% Create NaN column for alignment</span>
    sData_cossarini.data = [nan_col, sData_cossarini.data];            <span class="comment">% Add NaN column to original data</span>
    sData_cossarini.data(:,1) = hg_codebook_denorm;                    <span class="comment">% Replace first column with denormalized BMU values</span>
    sData_cossarini.data = cat(2,latlon_sliced,sData_cossarini.data);  <span class="comment">% Collate lat/lon to data</span>

    varName = sprintf(<span class="string">'sData_cossarini_%dm'</span>, round(dpth_m));      <span class="comment">% Generate variable name based on depth</span>
    fprintf(<span class="string">'Saving variable: %s\n'</span>, varName);                    <span class="comment">% Print saving info</span>
    eval([varName <span class="string">' = sData_cossarini.data;'</span>]);                   <span class="comment">% Assign data to variable with dynamic name</span>
    outputFile = <span class="string">'MeHg_Cossarini_SOM_MultiZlevel.mat'</span>;            <span class="comment">% Output .mat file name</span>
    save(outputFile, varName, <span class="string">'-append'</span>);                         <span class="comment">% Save variable to .mat in append mode</span>

    <span class="comment">%% ============ Plot Hg as a Map ============</span>
    final_lon = flip(sData_cossarini.data(:,1));    <span class="comment">% flip longitude data</span>
    final_lat = flip(sData_cossarini.data(:,2));    <span class="comment">% flip latitude data</span>
    final_hg  = flip(sData_cossarini.data(:,3));    <span class="comment">% flip mercury values</span>

    figure(7+n);                                                     <span class="comment">% create a new figure for each depth</span>
    set(gcf, <span class="string">'Position'</span>, [100, 100, 1200, 400]);                     <span class="comment">% set figure size</span>
    scatter(final_lat, final_lon, 10, final_hg, <span class="string">'filled'</span>);           <span class="comment">% plot scatter of mercury values</span>
    colorbar;                                                        <span class="comment">% show colorbar</span>
    caxis([0 0.4]);                                                  <span class="comment">% fix color scale from 0.0 to 0.4</span>
    xlabel(<span class="string">'Longitude'</span>);                                             <span class="comment">% label x-axis</span>
    ylabel(<span class="string">'Latitude'</span>);                                              <span class="comment">% label y-axis</span>
    xlim([-7 36]);                                                   <span class="comment">% ticks x-axis</span>
    ylim([30 46]);                                                   <span class="comment">% ticks y-axis</span>
    title(sprintf(<span class="string">'Depth: %.1f m'</span>, dpth_m));                         <span class="comment">% set title with depth</span>
    filename = sprintf(<span class="string">'MeHg_Cossarini_depth_%.1f.png'</span>, dpth_m);     <span class="comment">% prepare filename</span>
    saveas(gcf, filename);                                           <span class="comment">% save figure as PNG</span>

<span class="keyword">end</span>

fprintf(<span class="string">'\nAll depths processed and saved to %s\n'</span>, outputFile);   <span class="comment">% Print completion message</span>

clear i idx k n varid         <span class="comment">% Clear temporary variables from workspace</span>
</pre>

<pre class="oct-code-output">error: 'som_data_struct' undefined near line 26, column 23
	in:

for n = 1:length(slice)                            % Loop over each depth slice

    %% ========== Data Preparation ===============
    latlon_sliced = latlon_matrix;                 % Copy lat/lon for current slice
    idx = slice(n);                                % Current depth index
    dpth_m = dpths_m(n);                           % Current depth in meters

    fprintf('\nProcessing depth index %d (%.1f m)...\n', idx, dpth_m);  % Print processing info

    slicedataT  = dataT(:, :, idx);                           % Extract temperature at current depth
    slicedataO  = dataO(:, :, idx);                           % Extract oxygen at current depth
    slicedataso = dataso(:, :, idx);                          % Extract salinity at current depth

    slicedataT  = slicedataT(:);                              % Flatten temperature
    slicedataO  = slicedataO(:);                              % Flatten oxygen
    slicedataso = slicedataso(:);                             % Flatten salinity

    latlon_sliced(slicedataT == 1e+20, :) = [];               % Remove lat/lon where temperature is missing
    slicedataT(slicedataT == 1e+20) = [];                     % Remove missing temperature values
    slicedataO(slicedataO == 1e+20) = [];                     % Remove missing oxygen values
    slicedataso(slicedataso == 1e+20) = [];                   % Remove missing salinity values

    slicedata = cat(2, slicedataT, slicedataso, slicedataO);  % Combine T, Sal, O2 into one matrix

    %% ========== Data Elaboration ===============
    sData_cossarini = som_data_struct(slicedata, 'name', 'Cossarini Dataset', 'comp_names', {'Temp','Sal','O2_uM'});  % Create SOM data struct

    sData_cossarini_newT  = som_normalize(sData_cossarini.data(:,1), sData.comp_norm{2});  % Normalize temperature
    sData_cossarini_newSO = som_normalize(sData_cossarini.data(:,2), sData.comp_norm{3});  % Normalize salinity
    sData_cossarini_newO  = som_normalize(sData_cossarini.data(:,3), sData.comp_norm{4});  % Normalize oxygen

    nRows = size(sData_cossarini_newT, 1);                                                               % Number of rows in normalized temperature
    nan_col = nan(nRows, 1);                                                                             % Create column of NaNs for alignment
    sData_cossarini_new = [nan_col, sData_cossarini_newT, sData_cossarini_newSO, sData_cossarini_newO];  % Combine NaN + normalized data
    bmus_surfaceGP = som_bmus(sMap, sData_cossarini_new);                                                % Compute BMUs (best matching units)
    hg_codebook = sMap.codebook(bmus_surfaceGP, 1);                                                      % Extract corresponding codebook entries
    hg_codebook_denorm = som_denormalize(hg_codebook, sMap.comp_norm(1));                                % Denormalize BMU values

    nRows = size(sData_cossarini.data, 1);                             % Number of rows in original data
    nan_col = nan(nRows, 1);                                           % Create NaN column for alignment
    sData_cossarini.data = [nan_col, sData_cossarini.data];            % Add NaN column to original data
    sData_cossarini.data(:,1) = hg_codebook_denorm;                    % Replace first column with denormalized BMU values
    sData_cossarini.data = cat(2,latlon_sliced,sData_cossarini.data);  % Collate lat/lon to data

    varName = sprintf('sData_cossarini_%dm', round(dpth_m));      % Generate variable name based on depth
    fprintf('Saving variable: %s\n', varName);                    % Print saving info
    eval([varName ' = sData_cossarini.data;']);                   % Assign data to variable with dynamic name
    outputFile = 'MeHg_Cossarini_SOM_MultiZlevel.mat';            % Output .mat file name
    save(outputFile, varName, '-append');                         % Save variable to .mat in append mode

    %% ============ Plot Hg as a Map ============
    final_lon = flip(sData_cossarini.data(:,1));    % flip longitude data
    final_lat = flip(sData_cossarini.data(:,2));    % flip latitude data
    final_hg  = flip(sData_cossarini.data(:,3));    % flip mercury values

    figure(7+n);                                                     % create a new figure for each depth
    set(gcf, 'Position', [100, 100, 1200, 400]);                     % set figure size
    scatter(final_lat, final_lon, 10, final_hg, 'filled');           % plot scatter of mercury values
    colorbar;                                                        % show colorbar
    caxis([0 0.4]);                                                  % fix color scale from 0.0 to 0.4
    xlabel('Longitude');                                             % label x-axis
    ylabel('Latitude');                                              % label y-axis
    xlim([-7 36]);                                                   % ticks x-axis
    ylim([30 46]);                                                   % ticks y-axis
    title(sprintf('Depth: %.1f m', dpth_m));                         % set title with depth
    filename = sprintf('MeHg_Cossarini_depth_%.1f.png', dpth_m);     % prepare filename
    saveas(gcf, filename);                                           % save figure as PNG

end

fprintf('\nAll depths processed and saved to %s\n', outputFile);   % Print completion message

clear i idx k n varid         % Clear temporary variables from workspace



</pre>
<h2><a id="node34">=============================================================</a></h2><h2><a id="node35">===================== ROSATI MODEL ==========================</a></h2><h2><a id="node36">=============================================================</a></h2>
<pre class="oct-code">baseFolder_rosati = <span class="string">'Rosati_Data_Model_Output/'</span>;       <span class="comment">% Base folder containing NetCDF files</span>
fileNames_rosati = { ...                               <span class="comment">% List of NetCDF file names to process</span>
    <span class="string">'ave.20140616-00_00_00.DMHg.nc'</span>, ...
    <span class="string">'ave.20140616-00_00_00.MMHg.nc'</span>, ...
};
files_rosati = cellfun(@(f) fullfile(baseFolder_rosati, f), fileNames_rosati, <span class="string">'UniformOutput'</span>, false);  <span class="comment">% Create full paths for all files</span>
allVarNames_rosati = cell(1, numel(files_rosati));                                                      <span class="comment">% Initialize cell array to store variable names for each file</span>

ncid = netcdf.open(files_rosati{1}, <span class="string">'NC_NOWRITE'</span>);  <span class="comment">% Open first NetCDF file (PSAL) in read-only mode</span>
varid = netcdf.inqVarID(ncid, <span class="string">'DMHg'</span>);              <span class="comment">% Get variable ID for 'so' (salinity)</span>
datadmhg = netcdf.getVar(ncid, varid);              <span class="comment">% Read the 'so' variable data into MATLAB/Octave</span>
netcdf.close(ncid);                                 <span class="comment">% Close the first NetCDF file</span>
ncid = netcdf.open(files_rosati{2}, <span class="string">'NC_NOWRITE'</span>);  <span class="comment">% Open first NetCDF file (PSAL) in read-only mode</span>
varid = netcdf.inqVarID(ncid, <span class="string">'MMHg'</span>);              <span class="comment">% Get variable ID for 'so' (salinity)</span>
datammhg = netcdf.getVar(ncid, varid);              <span class="comment">% Read the 'so' variable data into MATLAB/Octave</span>
netcdf.close(ncid);                                 <span class="comment">% Close the first NetCDF file</span>

ncid = netcdf.open(files_rosati{1}, <span class="string">'NC_NOWRITE'</span>);            <span class="comment">% Re-open first file to get latitude</span>
datalat = netcdf.getVar(ncid, netcdf.inqVarID(ncid, <span class="string">'lat'</span>));  <span class="comment">% Read latitude</span>
netcdf.close(ncid);
ncid = netcdf.open(files_rosati{1}, <span class="string">'NC_NOWRITE'</span>);            <span class="comment">% Re-open first file to get longitude</span>
datalon = netcdf.getVar(ncid, netcdf.inqVarID(ncid, <span class="string">'lon'</span>));  <span class="comment">% Read longitude</span>
netcdf.close(ncid);
ncid = netcdf.open(files_rosati{1}, <span class="string">'NC_NOWRITE'</span>);            <span class="comment">% Re-open first file to get depth</span>
varid = netcdf.inqVarID(ncid, <span class="string">'depth'</span>);                       <span class="comment">% Get variable ID for depth</span>
datadepth = netcdf.getVar(ncid, varid);                       <span class="comment">% Read depth variable</span>

datamehg = datadmhg + datammhg;

clear i ncid nvars varname varid     <span class="comment">% Clear temporary variables from workspace</span>

z_level = [1, 5, 8, 11, 14, 16, 26];                                <span class="comment">% Define indices of depth slices to process</span>
slice   = [z_level];                                                <span class="comment">% Copy z_level into slice variable</span>
dpths_m = [1.0182, 10.537, 19.398, 29.886, 42.145, 51.38, 112.25];  <span class="comment">% Depths in meters corresponding to indices</span>

<span class="comment">% Create coordinate indexing</span>
[lat_grid, lon_grid] = meshgrid(datalat,datalon);  <span class="comment">% Create 2D grid of lat/lon</span>
flat_lat = lat_grid(:);                            <span class="comment">% Flatten latitude grid</span>
flat_lon = lon_grid(:);                            <span class="comment">% Flatten longitude grid</span>
latlon_matrix = [flat_lat, flat_lon];              <span class="comment">% Combine lat/lon into single matrix</span>
</pre>

<pre class="oct-code-output">error: No such file or directory
	in:

baseFolder_rosati = 'Rosati_Data_Model_Output/';       % Base folder containing NetCDF files
fileNames_rosati = { ...                               % List of NetCDF file names to process
    'ave.20140616-00_00_00.DMHg.nc', ...
    'ave.20140616-00_00_00.MMHg.nc', ...
};
files_rosati = cellfun(@(f) fullfile(baseFolder_rosati, f), fileNames_rosati, 'UniformOutput', false);  % Create full paths for all files
allVarNames_rosati = cell(1, numel(files_rosati));                                                      % Initialize cell array to store variable names for each file

ncid = netcdf.open(files_rosati{1}, 'NC_NOWRITE');  % Open first NetCDF file (PSAL) in read-only mode
varid = netcdf.inqVarID(ncid, 'DMHg');              % Get variable ID for 'so' (salinity)
datadmhg = netcdf.getVar(ncid, varid);              % Read the 'so' variable data into MATLAB/Octave
netcdf.close(ncid);                                 % Close the first NetCDF file
ncid = netcdf.open(files_rosati{2}, 'NC_NOWRITE');  % Open first NetCDF file (PSAL) in read-only mode
varid = netcdf.inqVarID(ncid, 'MMHg');              % Get variable ID for 'so' (salinity)
datammhg = netcdf.getVar(ncid, varid);              % Read the 'so' variable data into MATLAB/Octave
netcdf.close(ncid);                                 % Close the first NetCDF file

ncid = netcdf.open(files_rosati{1}, 'NC_NOWRITE');            % Re-open first file to get latitude
datalat = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'lat'));  % Read latitude
netcdf.close(ncid);
ncid = netcdf.open(files_rosati{1}, 'NC_NOWRITE');            % Re-open first file to get longitude
datalon = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'lon'));  % Read longitude
netcdf.close(ncid);
ncid = netcdf.open(files_rosati{1}, 'NC_NOWRITE');            % Re-open first file to get depth
varid = netcdf.inqVarID(ncid, 'depth');                       % Get variable ID for depth
datadepth = netcdf.getVar(ncid, varid);                       % Read depth variable

datamehg = datadmhg + datammhg;

clear i ncid nvars varname varid     % Clear temporary variables from workspace

z_level = [1, 5, 8, 11, 14, 16, 26];                                % Define indices of depth slices to process
slice   = [z_level];                                                % Copy z_level into slice variable
dpths_m = [1.0182, 10.537, 19.398, 29.886, 42.145, 51.38, 112.25];  % Depths in meters corresponding to indices

% Create coordinate indexing
[lat_grid, lon_grid] = meshgrid(datalat,datalon);  % Create 2D grid of lat/lon
flat_lat = lat_grid(:);                            % Flatten latitude grid
flat_lon = lon_grid(:);                            % Flatten longitude grid
latlon_matrix = [flat_lat, flat_lon];              % Combine lat/lon into single matrix
</pre>
<h2><a id="node37">===================== 1. Loop over depth slices =====================</a></h2>
<pre class="oct-code"><span class="keyword">for</span> n = 1:length(slice)         <span class="comment">% Loop over each depth slice</span>

    <span class="comment">%% ========== Data Preparation ===============</span>
    idx = slice(n);             <span class="comment">% Current depth index</span>
    dpth_m = dpths_m(n);        <span class="comment">% Current depth in meters</span>
    fprintf(<span class="string">'\nProcessing depth index %d (%.1f m)...\n'</span>, idx, dpth_m);

    slicedataME = datamehg(:, :, idx);  <span class="comment">% Extract combined MEHg at current depth</span>
    slicedataME = slicedataME(:);       <span class="comment">% Flatten MEHg</span>

    latlon_sliced = latlon_matrix;      <span class="comment">% Copy lat/lon for current slice</span>


    mask = (slicedataME == 2e+20);      <span class="comment">% Remove missing values (assuming missing values are 1e+20 as in previous code)</span>
    latlon_sliced(mask, :) = [];
    slicedataME(mask) = [];

    sData_rosati = cat(2, latlon_sliced, slicedataME);

    <span class="comment">%% ========== Data Elaboration ===============</span>
    varName = sprintf(<span class="string">'sData_rosati_%dm'</span>, round(dpth_m));
    fprintf(<span class="string">'Saving variable: %s\n'</span>, varName);
    eval([varName <span class="string">' = sData_rosati;'</span>]);

    outputFile = <span class="string">'MeHg_Rosati_MultiZlevel.mat'</span>;
    save(outputFile, varName, <span class="string">'-append'</span>);   <span class="comment">% Save to .mat file (append)</span>

    <span class="comment">%% ============ Plot MEHg as a Map ============</span>
    final_lon = flip(latlon_sliced(:,1));   <span class="comment">% flip longitude</span>
    final_lat = flip(latlon_sliced(:,2));   <span class="comment">% flip latitude</span>
    final_mehg = flip(slicedataME);         <span class="comment">% flip MEHg values</span>

    figure(14+n);                                                 <span class="comment">% new figure for each depth</span>
    set(gcf, <span class="string">'Position'</span>, [100, 100, 1200, 400]);                  <span class="comment">% set figure size</span>
    scatter(final_lat, final_lon, 10, final_mehg, <span class="string">'filled'</span>);      <span class="comment">% scatter plot</span>
    colorbar;                                                     <span class="comment">% show colorbar</span>
    caxis([0 0.4]);                                               <span class="comment">% fix color scale from 0.0 to 0.4</span>
    xlabel(<span class="string">'Longitude'</span>);                                          <span class="comment">% label x-axis</span>
    ylabel(<span class="string">'Latitude'</span>);                                           <span class="comment">% label y-axis</span>
    xlim([-7 36]);                                                <span class="comment">% ticks x-axis</span>
    ylim([30 46]);                                                <span class="comment">% ticks y-axis</span>
    title(sprintf(<span class="string">'ROSATI Model MEHg - Depth: %.1f m'</span>, dpth_m));  <span class="comment">% set title with depth</span>
    filename = sprintf(<span class="string">'MeHg_Rosati_depth_%.1f.png'</span>, dpth_m);     <span class="comment">% prepare filename</span>
    saveas(gcf, filename);                                        <span class="comment">% save figure as PNG</span>

<span class="keyword">end</span>

fprintf(<span class="string">'\nAll ROSATI depths processed and saved to %s\n'</span>, outputFile);   <span class="comment">% Print completion message</span>

clear idx n mask latlon_sliced final_lat final_lon final_mehg    <span class="comment">% Clear temporary variables from workspace</span>
</pre>

<pre class="oct-code-output">error: 'datamehg' undefined near line 8, column 19
	in:

for n = 1:length(slice)         % Loop over each depth slice

    %% ========== Data Preparation ===============
    idx = slice(n);             % Current depth index
    dpth_m = dpths_m(n);        % Current depth in meters
    fprintf('\nProcessing depth index %d (%.1f m)...\n', idx, dpth_m);

    slicedataME = datamehg(:, :, idx);  % Extract combined MEHg at current depth
    slicedataME = slicedataME(:);       % Flatten MEHg

    latlon_sliced = latlon_matrix;      % Copy lat/lon for current slice


    mask = (slicedataME == 2e+20);      % Remove missing values (assuming missing values are 1e+20 as in previous code)
    latlon_sliced(mask, :) = [];
    slicedataME(mask) = [];

    sData_rosati = cat(2, latlon_sliced, slicedataME);

    %% ========== Data Elaboration ===============
    varName = sprintf('sData_rosati_%dm', round(dpth_m));
    fprintf('Saving variable: %s\n', varName);
    eval([varName ' = sData_rosati;']);

    outputFile = 'MeHg_Rosati_MultiZlevel.mat';
    save(outputFile, varName, '-append');   % Save to .mat file (append)

    %% ============ Plot MEHg as a Map ============
    final_lon = flip(latlon_sliced(:,1));   % flip longitude
    final_lat = flip(latlon_sliced(:,2));   % flip latitude
    final_mehg = flip(slicedataME);         % flip MEHg values

    figure(14+n);                                                 % new figure for each depth
    set(gcf, 'Position', [100, 100, 1200, 400]);                  % set figure size
    scatter(final_lat, final_lon, 10, final_mehg, 'filled');      % scatter plot
    colorbar;                                                     % show colorbar
    caxis([0 0.4]);                                               % fix color scale from 0.0 to 0.4
    xlabel('Longitude');                                          % label x-axis
    ylabel('Latitude');                                           % label y-axis
    xlim([-7 36]);                                                % ticks x-axis
    ylim([30 46]);                                                % ticks y-axis
    title(sprintf('ROSATI Model MEHg - Depth: %.1f m', dpth_m));  % set title with depth
    filename = sprintf('MeHg_Rosati_depth_%.1f.png', dpth_m);     % prepare filename
    saveas(gcf, filename);                                        % save figure as PNG

end

fprintf('\nAll ROSATI depths processed and saved to %s\n', outputFile);   % Print completion message

clear idx n mask latlon_sliced final_lat final_lon final_mehg    % Clear temporary variables from workspace



</pre>
<h2><a id="node38">============================================================</a></h2><h2><a id="node39">====================== ERROR MEASURE =======================</a></h2><h2><a id="node40">============================================================</a></h2>
<pre class="oct-code">clear  <span class="comment">% clear workspace</span>
</pre>
<h2><a id="node41">============ Load Data ============</a></h2>
<pre class="oct-code">load(<span class="string">'MeHg_Cossarini_SOM_MultiZlevel.mat'</span>)
load(<span class="string">'MeHg_Rosati_MultiZlevel.mat'</span>)
depths = {<span class="string">'1m'</span>, <span class="string">'11m'</span>, <span class="string">'19m'</span>, <span class="string">'30m'</span>, <span class="string">'42m'</span>, <span class="string">'51m'</span>, <span class="string">'112m'</span>};   <span class="comment">% list of model depth levels</span>
</pre>

<pre class="oct-code-output">error: load: unable to find file MeHg_Cossarini_SOM_MultiZlevel.mat
	in:

load('MeHg_Cossarini_SOM_MultiZlevel.mat')
load('MeHg_Rosati_MultiZlevel.mat')
depths = {'1m', '11m', '19m', '30m', '42m', '51m', '112m'};   % list of model depth levels
</pre>
<h2><a id="node42">============ Custom Red-White-Blue Colorbar ============</a></h2>
<pre class="oct-code"><span class="keyword">function</span> cmap = redwhiteblue(n)                 <span class="comment">% define red-white-blue colormap</span>
  <span class="keyword">if</span> nargin &lt; 1
      n = 256;                                  <span class="comment">% default number of colors</span>
  <span class="keyword">end</span>
  half = floor(n/2);                            <span class="comment">% split color range in half</span>
  r = [(0:half-1)<span class="string">'/half; ones(half,1)];         % red increases from 01, stays 1</span>
  g = [(0:half-1)<span class="string">'/half; (half-1:-1:0)'</span>/half];  <span class="comment">% green goes up then down</span>
  b = [ones(half,1); (half-1:-1:0)<span class="string">'/half];      % blue starts at 1 then fades</span>
  cmap = [r g b];                               <span class="comment">% combine RGB into colormap</span>
<span class="keyword">end</span></pre>
<h2><a id="node43">============ Main Loop ============</a></h2>
<pre class="oct-code"><span class="keyword">for</span> n = 1:length(depths)                        <span class="comment">% Loop over each depth slice</span>
  depth = depths{n};                            <span class="comment">% current depth string (e.g. '1m')</span>

  coss_name = [<span class="string">'sData_cossarini_'</span> depth];       <span class="comment">% sData_cossarini_1m</span>
  ros_name  = [<span class="string">'sData_rosati_'</span> depth];          <span class="comment">% sData_rosati_1m</span>

  coss_data = eval(coss_name);                  <span class="comment">% get matrix from workspace</span>
  ros_data  = eval(ros_name);                   <span class="comment">% get matrix from workspace</span>

  lat_c = coss_data(:,1);                       <span class="comment">% Cossarini latitude</span>
  lon_c = coss_data(:,2);                       <span class="comment">% Cossarini longitude</span>
  val_c = coss_data(:,3);                       <span class="comment">% Cossarini value</span>
  lat_r = ros_data(:,1);                        <span class="comment">% Rosati latitude</span>
  lon_r = ros_data(:,2);                        <span class="comment">% Rosati longitude</span>
  val_r = ros_data(:,3);                        <span class="comment">% Rosati value</span>

  coords_c = [lat_c, lon_c];                    <span class="comment">% coordinates from Cossarini</span>
  coords_r = [lat_r, lon_r];                    <span class="comment">% coordinates from Rosati</span>

  [common_coords, idx_c, idx_r] = intersect(coords_c, coords_r, <span class="string">'rows'</span>); <span class="comment">% match by (lat, lon)</span>

  diff_val = val_c(idx_c) - val_r(idx_r);       <span class="comment">% difference of third column</span>
  diff_data = [common_coords, diff_val];        <span class="comment">% combined result [lat lon diff]</span>

  diff_name = sprintf(<span class="string">'diff_%s'</span>, depth);                <span class="comment">% Create variable name (e.g. diff_1m)</span>
  fprintf(<span class="string">'Saving variable: %s\n'</span>, diff_name);          <span class="comment">% Announce what is being saved</span>
  eval([diff_name <span class="string">' = diff_data;'</span>]);                    <span class="comment">% Assign dynamically</span>
  outputFile = <span class="string">'MeHg_Difference_Cossarini_Rosati.mat'</span>;  <span class="comment">% Save to .mat file (append mode)</span>
  save(outputFile, diff_name, <span class="string">'-append'</span>);

  <span class="comment">%% ============ Plot Difference ============</span>
  figure(14 + n);                               <span class="comment">% create a new figure per depth</span>
  set(gcf, <span class="string">'Position'</span>, [100, 100, 1200, 400]);  <span class="comment">% set figure window size</span>
  ax = gca;
  hold on;
  fill([-7 36 36 -7], [30 30 46 46], [0.8 0.8 0.8], <span class="string">'EdgeColor'</span>, <span class="string">'none'</span>);   <span class="comment">% gray background (land)</span>
  scatter(common_coords(:,2), common_coords(:,1), 10, diff_val, <span class="string">'filled'</span>);  <span class="comment">% scatter plot colored by diff</span>
  colormap(redwhiteblue());                                                 <span class="comment">% apply red-white-blue colormap</span>
  colorbar;                                                                 <span class="comment">% show color scale</span>

  clim = max(abs(diff_val));    <span class="comment">% find max abs difference</span>
  caxis([-clim clim]);          <span class="comment">% symmetric color axis limits</span>

  xlabel(<span class="string">'Longitude'</span>);                                                                       <span class="comment">% X label</span>
  ylabel(<span class="string">'Latitude'</span>);                                                                        <span class="comment">% Y label</span>
  xlim([-7 36]);                                                                             <span class="comment">% longitude range</span>
  ylim([30 46]);                                                                             <span class="comment">% latitude range</span>
  title(sprintf(<span class="string">'Cossarini - Rosati Difference at Depth: %s'</span>, depth), <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>); <span class="comment">% title</span>

  filename = sprintf(<span class="string">'MeHg_Difference_Cossarini_minus_Rosati_%s.png'</span>, depth);  <span class="comment">% output file name</span>
  saveas(gcf, filename);                                                  <span class="comment">% save figure to file</span>

  fprintf(<span class="string">'Depth %s: computed %d matching points and saved plot "%s".\n'</span>, depth, rows(diff_data), filename);  <span class="comment">% print progress info</span>

<span class="keyword">end</span>

clear ax clim common_coords coords_c coords_r coss_data coss_name ...    <span class="comment">% Clear temporary variables from workspace</span>
  depth depths diff_data diff_name diff_val filename ...                 <span class="comment">% Clear temporary variables from workspace</span>
  idx_c idx_r lat_c lat_r lon_c lon_r ros_data n ros_name val_c val_r    <span class="comment">% Clear temporary variables from workspace</span>
</pre>

<pre class="oct-code-output">error: 'depths' undefined near line 1, column 18
	in:

for n = 1:length(depths)                        % Loop over each depth slice
  depth = depths{n};                            % current depth string (e.g. '1m')

  coss_name = ['sData_cossarini_' depth];       % sData_cossarini_1m
  ros_name  = ['sData_rosati_' depth];          % sData_rosati_1m

  coss_data = eval(coss_name);                  % get matrix from workspace
  ros_data  = eval(ros_name);                   % get matrix from workspace

  lat_c = coss_data(:,1);                       % Cossarini latitude
  lon_c = coss_data(:,2);                       % Cossarini longitude
  val_c = coss_data(:,3);                       % Cossarini value
  lat_r = ros_data(:,1);                        % Rosati latitude
  lon_r = ros_data(:,2);                        % Rosati longitude
  val_r = ros_data(:,3);                        % Rosati value

  coords_c = [lat_c, lon_c];                    % coordinates from Cossarini
  coords_r = [lat_r, lon_r];                    % coordinates from Rosati

  [common_coords, idx_c, idx_r] = intersect(coords_c, coords_r, 'rows'); % match by (lat, lon)

  diff_val = val_c(idx_c) - val_r(idx_r);       % difference of third column
  diff_data = [common_coords, diff_val];        % combined result [lat lon diff]

  diff_name = sprintf('diff_%s', depth);                % Create variable name (e.g. diff_1m)
  fprintf('Saving variable: %s\n', diff_name);          % Announce what is being saved
  eval([diff_name ' = diff_data;']);                    % Assign dynamically
  outputFile = 'MeHg_Difference_Cossarini_Rosati.mat';  % Save to .mat file (append mode)
  save(outputFile, diff_name, '-append');

  %% ============ Plot Difference ============
  figure(14 + n);                               % create a new figure per depth
  set(gcf, 'Position', [100, 100, 1200, 400]);  % set figure window size
  ax = gca;
  hold on;
  fill([-7 36 36 -7], [30 30 46 46], [0.8 0.8 0.8], 'EdgeColor', 'none');   % gray background (land)
  scatter(common_coords(:,2), common_coords(:,1), 10, diff_val, 'filled');  % scatter plot colored by diff
  colormap(redwhiteblue());                                                 % apply red-white-blue colormap
  colorbar;                                                                 % show color scale

  clim = max(abs(diff_val));    % find max abs difference
  caxis([-clim clim]);          % symmetric color axis limits

  xlabel('Longitude');                                                                       % X label
  ylabel('Latitude');                                                                        % Y label
  xlim([-7 36]);                                                                             % longitude range
  ylim([30 46]);                                                                             % latitude range
  title(sprintf('Cossarini - Rosati Difference at Depth: %s', depth), 'FontWeight', 'bold'); % title

  filename = sprintf('MeHg_Difference_Cossarini_minus_Rosati_%s.png', depth);  % output file name
  saveas(gcf, filename);                                                  % save figure to file

  fprintf('Depth %s: computed %d matching points and saved plot "%s".\n', depth, rows(diff_data), filename);  % print progress info

end

clear ax clim common_coords coords_c coords_r coss_data coss_name ...    % Clear temporary variables from workspace
  depth depths diff_data diff_name diff_val filename ...                 % Clear temporary variables from workspace
  idx_c idx_r lat_c lat_r lon_c lon_r ros_data n ros_name val_c val_r    % Clear temporary variables from workspace



</pre>
<h2><a id="node44">============================================================</a></h2><h2><a id="node45">===================== CLOSE ALL PLOTS ======================</a></h2><h2><a id="node46">============================================================</a></h2>
<pre class="oct-code">close all           <span class="comment"># Close all plots</span>
</pre>

<footer>
<hr>
<a href="https://www.octave.org">Published with GNU Octave 10.3.0</a>
</footer>
<!--
##### SOURCE BEGIN #####
% SOM Tool Box original files at http://www.cis.hut.fi/somtoolbox/download/, click on [SOM Toolbox 2.0 (Mar 17 2005)]
% The "somtoolbox" folder is identical to the original except for the file "som_make" which now allows algorithm, initalg, mapsize and training to be selected from here
% The experiments were performed using "Octave-10.3.0" during the October of 2025.
% List of the files:
%   Cossarini_Model_Output/
%             20200101_y-CMCC--PSAL-MFSe3r1-MED-b20220901_re-sv01.00.nc
%             20200101_y-CMCC--TEMP-MFSe3r1-MED-b20220901_re-sv01.00.nc
%             20200101_y-OGS--BIOL-MedBFM3-MED-b20221120_re-sv05.00.nc
%   Rosati_Data_Model_Output/
%             ave.20140616-00_00_00.DMHg.nc
%             ave.20140616-00_00_00.MMHg.nc
%             data_ancillary_DGM.csv
%             data_ancillary_HgT.csv
%             data_ancillary_MeHg.csv
%   somtoolbox/
%             SOM original scripts
%   Puglia_Hg_SOM.m (THIS FILE)

%% ============================================================
%% ========================= START ============================
%% ============================================================
clc                                                                                                  % Clean command window
clear                                                                                                % Clean workspace
DIR = "C:/Users/mpuglia/OneDrive - OGS/Desktop/Puglia_Bandelj_Cossarini_Rosati_Experiment_10-2025";  % Main Path
cd(DIR)                                                                                              % Set directory
addpath('somtoolbox');                                                                               % Path to the original functions




%% ============================================================
%% ================= OCTAVE Needed Packages ===================
%% ============================================================
%pkg install -forge netcdf         % Install the NetCDF package (uncomment if not installed)
pkg load netcdf                    % Load the NetCDF package in Octave
pkg load io                        % Only needed if the io package is not already loaded




%% ============================================================
%% ================ Rosati's Hg Observations ==================
%% ============================================================

%% ===================== 0. Load data =====================
dataset = csvread('Rosati_Data_Model_Output/data_ancillary_MeHg.csv', 1, 0);     % Load dataset
datasetval = dataset(:, [9 10 11 12]);                                           % Select MeHg/HgT, Temp, Sal, O2 observations
%datasetval = dataset(:, [11 16 17 18]);                                         % Select DGM, Temp, Sal, O2 observations

%% ===================== 1. Data into structure =====================
sData = som_data_struct(datasetval, 'name', 'MeHg Dataset', 'comp_names', {'MeHg','Temp','Sal','O2_uM'});  % Wrap in SOM Toolbox data structure


%% ===================== 2. Normalize data =====================

sData = som_normalize(sData, 'var');                    % Normalize data


%% ===================== 3. Create, initialize and train a SOM. =====================
% 'algorithm'  *(string) training: 'seq' or 'batch' (default) or 'sompak'
% 'init'       *(string) initialization: 'randinit' or 'lininit' (default)
% 'mapsize'    *(string) do you want a 'small', 'normal' or 'big' map
% 'training'    (string) 'short', 'default' or 'long'
algorithm = 'seq';                                              % Selected: 'seq'/'batch'
initalg = 'lininit';                                            % Selected: 'lininit'
mapsize = 'big';                                                % Selected: 'big'
training = 'long';                                              % Selected: 'long'
sMap = som_make(sData, algorithm, initalg, mapsize, training);  % Train the SOM with sData and specified options

clear algorithm initalg mapsize training                        % Clear temporary variables from workspace

%% ===================== 4. Find Final BEST-MATCHING UNITS (BMUs) =====================
bmus = som_bmus(sMap, sData);                           % Find the Best-Matching Unit (BMU) for each data sample in sData using the trained SOM


%% ===================== 5. SOM quality metrics =====================
[q, t] = som_quality(sMap, sData);                      % Compute SOM quality metrics: q = quantization error, t = topographic error


%% ===================== 6. Save results =====================
save('C:\Users\mpuglia\MeHg_Rosati_SOM_Observations.mat')


%% =====================================================
%% ===== PLOTS ===== PLOTS ===== PLOTS ===== PLOTS =====
%% =====================================================

%% ===================== 7. Visualize component planes =====================
figure(1);                                       % Open figure

colormap(1-gray)                                 % Use an inverted grayscale colormap for better contrast
som_show(sMap, 'norm', 'd');                     % Display the SOM component planes normalized by distance
text(1, -7, 'Component planes for MeHg', ...     % Add a title text to the figure at position (1, -7)
     'HorizontalAlignment', 'center', ...        % Center the text horizontally
     'FontSize', 14, 'FontWeight', 'bold');      % Use larger, bold font for emphasis
saveas(gcf, 'MeHg_SOM_component_planes.png');    % Save as PNG


%% ===================== 8. Hit Plots =====================
hit = som_hits(sMap, sData);                     % Compute the number of data samples (hits) mapped to each SOM node

% ====== Plot marks based on size ======
figure(2);                                             % Open figure

colormap(1-gray)                                       % Set colormap to inverted grayscale for better contrast
som_show(sMap, 'norm', 'd', 'umat', 'all');            % Display only the U-Matrix (distance map) of the SOM
som_show_add('hit', hit, ...                           % Overlay hit markers on the SOM map
             'MarkerColor', 'r', 'MarkerSize', 0.5);   % Set marker color to red and marker size to 0.5
title('SOM Hits Sized Marks');                         % Add a title to the plot
saveas(gcf, 'MeHg_SOM_hit_mark.png');       % Save as PNG

% ====== Plot numeric hit counts ======
figure(3);                                                                   % Open figure

colormap(1-gray)                                                             % Set colormap to inverted grayscale for better contrast
som_show(sMap, 'norm', 'd', 'umat', 'all');                                  % Display only the U-Matrix (distance map) of the SOM
pos = som_unit_coords(sMap);                                                 % Get the (x, y) coordinates of all SOM units (neurons)

x_offset = 0.9;                                                              % Horizontal offset
y_offset = 0.9;                                                              % Vertical offset
pos(:,1) = pos(:,1) * sqrt(3)/1.73;                                          % Horizontal scale
pos(:,2) = pos(:,2) * 1.155;                                                 % Vertical scale

for i = 1:length(hit)                                                        % Loop through each SOM unit
    if hit(i) > 0                                                            % Only label units that have one or more hits
        text(pos(i,1) + x_offset, pos(i,2) + y_offset, num2str(hit(i)), ...  % Place text near the unit showing the hit count
              'Color', 'r', 'FontSize', 10, 'FontWeight', 'bold');           % Set text color, size, and bold font for visibility
    end
end
title('SOM Hit Numbers');                                                    % Add a title to the plot
saveas(gcf, 'MeHg_SOM_hit_number.png');       % Save as PNG


% ====== Plot regional labels ======
figure(4);                                                                   % Open figure

textdata = csv2cell('Rosati_Data_Model_Output/data_ancillary_MeHg.csv');     % Read CSV file into a cell array
RegionalLabels = textdata(2:end,5);                                          % Extract the regional labels from the 5th column (skip header row)
sData.labels = RegionalLabels;                                               % Initialize your SOM data structure labels with regional labels
map_keys   = {'SAD','TYR2','ION1_2','LEV','SWM','ALB','NWM','ION3','TYR1'};  % Original CSV labels
map_values = {  'D',   'T',     'I',  'L',  'S',  'A',  'N',   'I',   'T'};  % Corresponding single-letter codes
mappedLabels = RegionalLabels;                                               % Initialize mappedLabels with the original labels

% Loop through each key in map_keys
for k = 1:length(map_keys)
    idx = strcmp(RegionalLabels, map_keys{k});                               % Find all occurrences of the current key in RegionalLabels
    mappedLabels(idx) = map_values(k);                                       % Replace matching labels with the corresponding single-letter code
end

sData.labels = mappedLabels;                                                 % Assign the mapped labels to the SOM data structure
sMap = som_autolabel(sMap, sData, 'vote');                                   % Automatically label the SOM map using the mapped labels
colormap(1-gray)                                                             % Set colormap to grayscale (1-gray inverts the grayscale)
som_show(sMap,'norm','d', 'umat', 'all');                                    % Display the SOM map with normalized distances
som_show_add('label', sMap, 'TextSize', 10, 'TextColor', 'r');               % Add labels normally
hText = findall(gca, 'Type', 'text');                                        % Get all text objects in the current axes
set(hText, 'FontWeight', 'bold');                                            % Set font weight to bold
title('SOM Regional Labels');                                                % Add a title to the plot
saveas(gcf, 'MeHg_SOM_hit_region.png');       % Save as PNG


%% ===================== 9. Map SOM units back to coordinates =====================    % NOT USEFUL OUTPUT PRODUCED
%figure(5);                                                                            % Open figure
%
%top = 100                                                                             % Select the top of the water column where to find the sample
%bottom = 120                                                                          % Select the bottom of the water column where to find the sample
%surface_idx = dataset(:,8) >= top & dataset(:,8) <= bottom;                           % Logical filter index for depths ># and <=#
%coords_surface = dataset(surface_idx, [4 3]);                                         % Extract Longitude (column 4) and Latitude (column 3) for surface points
%bmus_surface = bmus(surface_idx);                                                     % BMU values corresponding to surface points

%scatter(coords_surface(:,1), coords_surface(:,2), 50, bmus_surface, 'filled');        % Scatter plot of surface points colored by BMU; 50 = marker size, 'filled' = filled circles
%axis equal;                                                                           % Ensure x and y axes have the same scale
%xlim([-5 30]);                                                                        % Fixed longitude range (x-axis) from -5 to 30
%ylim([35 45]);                                                                        % Fixed latitude range (y-axis) from 35 to 45
%colorbar;                                                                             % Show colorbar representing BMU indices
%xlabel('Longitude');                                                                  % Label x-axis
%ylabel('Latitude');                                                                   % Label y-axis
%title(sprintf('SOM Cluster Mediterranean Map - Depth %.1f to %.1f m', top, bottom));  % Add a title to the plot
%set(gcf, 'Position', [100, 100, 800, 250]);                                           % Resize figure window for better clarity

clear map_keys map_values mappedLabels x_offset y_offset     % Clear temporary variables from workspace




%% ============================================================
%% ================== Cossarini's Model Data ==================
%% ============================================================
idx_list = [1, 5, 8, 11, 14, 16, 26]      % Loop over the slice indexes at wich you want to make the plot

%% ===================== 1. Initialise =====================
baseFolder = 'Cossarini_Model_Output';                                             % Base folder containing NetCDF files
fileNames = { ...                                                                  % List of NetCDF file names to process
    '20200101_y-CMCC--PSAL-MFSe3r1-MED-b20220901_re-sv01.00.nc', ...
    '20200101_y-CMCC--TEMP-MFSe3r1-MED-b20220901_re-sv01.00.nc', ...
    '20200101_y-OGS--BIOL-MedBFM3-MED-b20221120_re-sv05.00.nc' ...
};

files = cellfun(@(f) fullfile(baseFolder, f), fileNames, 'UniformOutput', false);  % Create full paths for all files
allVarNames = cell(1, numel(files));                                               % Initialize cell array to store variable names for each file

for f = 1:numel(files)                                                             % Loop over each NetCDF file
    ncid = netcdf.open(files{f}, 'NC_NOWRITE');                                    % Open file in read-only mode
    [~, nvars, ~, ~] = netcdf.inq(ncid);                                           % Get the number of variables in the file
    varnames = cell(1, nvars);                                                     % Initialize cell array for variable names
    for i = 0:nvars-1                                                              % Loop through all variables
        [varname, ~, ~, ~] = netcdf.inqVar(ncid, i);                               % Get the variable name
        varnames{i+1} = varname;                                                   % Store in the cell array (MATLAB/Octave indexing starts at 1)
    end

    allVarNames{f} = varnames;                                                     % Store variable names for this file
    netcdf.close(ncid);                                                            % Close the NetCDF file
end

% Display variable names for each file
for f = 1:numel(files)                                                             % Loop over each file
    fprintf('Variables in file %d:\n', f);                                         % Print file index
    disp(allVarNames{f});                                                          % Display the variable names
end

clear f i ncid nvars varname varnames                                              % Clear temporary variables from workspace


%% ===================== 2. Load .nc files =====================
ncid = netcdf.open(files{1}, 'NC_NOWRITE');      % Open first NetCDF file (PSAL) in read-only mode
varid = netcdf.inqVarID(ncid, 'so');             % Get variable ID for 'so' (salinity)
dataso = netcdf.getVar(ncid, varid);             % Read the 'so' variable data into MATLAB/Octave
netcdf.close(ncid);                              % Close the first NetCDF file

ncid = netcdf.open(files{2}, 'NC_NOWRITE');      % Open second NetCDF file (TEMP) in read-only mode
varid = netcdf.inqVarID(ncid, 'thetao');         % Get variable ID for 'thetao' (temperature)
dataT = netcdf.getVar(ncid, varid);              % Read the 'thetao' variable data
netcdf.close(ncid);                              % Close the second NetCDF file

ncid = netcdf.open(files{3}, 'NC_NOWRITE');      % Open third NetCDF file (BIOL) in read-only mode
varid = netcdf.inqVarID(ncid, 'o2');             % Get variable ID for 'o2' (oxygen)
dataO = netcdf.getVar(ncid, varid);              % Read the 'o2' variable data
netcdf.close(ncid);                              % Close the third NetCDF file

clear ncid varid                                 % Clear temporary NetCDF handles from workspace

dataT = dataT(12:end, :, 1:125);                                    % Subset temperature data: skip first 11 rows, keep all columns, limit to first 125 depth levels
dataso = dataso(12:end, :, 1:125);                                  % Subset salinity data similarly


for idx = idx_list
    %% ===================== 3. Process the matrix =====================

    slice   = [1, 5, 8, 11, 14, 16, 26];                                % Depth indices corresponding to available depths
    dpths_m = [1.0182, 10.537, 19.398, 29.886, 42.145, 51.38, 112.25];  % Depth values in meters
    pos = find(slice == idx);                                           % Find the position of the selected idx in the slice array
    dpth_m = dpths_m(pos);                                              % Selected depth

    slicedataT  = dataT(:, :, idx);                                     % Extract temperature at selected depth(s)
    slicedataO  = dataO(:, :, idx);                                     % Extract oxygen at selected depth(s)
    slicedataso = dataso(:, :, idx);                                    % Extract salinity at selected depth(s)

    slicedataT  = slicedataT(:);                                        % Flatten temperature matrix into a column vector
    slicedataO  = slicedataO(:);                                        % Flatten oxygen matrix into a column vector
    slicedataso = slicedataso(:);                                       % Flatten salinity matrix into a column vector

    slicedataT(slicedataT == 1e+20) = [];                               % Remove fill/missing values from temperature
    slicedataO(slicedataO == 1e+20) = [];                               % Remove fill/missing values from oxygen
    slicedataso(slicedataso == 1e+20) = [];                             % Remove fill/missing values from salinity

    slicedata = cat(2, slicedataT, slicedataso, slicedataO);            % Concatenate temperature, salinity, and oxygen into one data matrix


    %% ===================== 4. SOM commands=====================
    sData_cossarini = som_data_struct(slicedata(1:end,1:3), 'name', 'Cossarini Dataset', 'comp_names', {'Temp','Sal','O2_uM'}); % Structure
    clear sData_cossarini_newT sData_cossarini_newSO sData_cossarini_newO sData_cossarini_new                                   % Clear variables before usage
    sData_cossarini_newT(:,1)  = som_normalize(sData_cossarini.data(:,1),sData.comp_norm{2});                                   % Normalization temperature
    sData_cossarini_newSO(:,1) = som_normalize(sData_cossarini.data(:,2),sData.comp_norm{3});                                   % Normalization salinity
    sData_cossarini_newO(:,1)  = som_normalize(sData_cossarini.data(:,3),sData.comp_norm{4});                                   % Normalization oxygen


    %% ===================== 5. BEST-MATCHING UNITS (BMUs) =====================
    nRows = size(sData_cossarini_newT, 1);                                               % Number of rows in temperature dataset
    nan_col = nan(nRows, 1);                                                             % Create a column of NaN values to align dataset dimensions
    sData_cossarini_new = [nan_col, sData_cossarini_newT, sData_cossarini_newSO, sData_cossarini_newO];  % Combine NaN column + Temp + Salinity + Oxygen into one matrix

    nRowssliced = size(slicedata, 1);                                                    % Number of rows in sliced (depth-specific) dataset
    nan_colsliced = nan(nRowssliced, 1);                                                 % Create a column of NaN values for sliced dataset
    sliced_denormalize = cat(2, nan_colsliced, slicedata);                               % Concatenate NaN column and sliced data to match SOM input format

    bmus_surfaceGP = som_bmus(sMap, sData_cossarini_new);                                % Find Best Matching Units (BMUs) for surface dataset
    bmus_surfaceGP_denorm = som_bmus(sMap, sliced_denormalize);                          % Find BMUs for denormalized sliced dataset



    %% =====================================================
    %% ===== PLOTS ===== PLOTS ===== PLOTS ===== PLOTS =====
    %% =====================================================

    %% ===================== 6. Hit Plots =====================
    hit_surfaceGP = som_hits(sMap, sData_cossarini_new);                                   % Compute the number of data samples (hits) mapped to each SOM node

    % ====== Plot numeric hit counts ======
    figure(6);                                                                             % Open figure
    colormap(1-gray)                                                                       % Set colormap to inverted grayscale for better contrast
    som_show(sMap, 'norm', 'd', 'umat', 'all');                                            % Display only the U-Matrix (distance map) of the SOM
    pos = som_unit_coords(sMap);                                                           % Get the (x, y) coordinates of all SOM units (neurons)

    x_offset = 0.9;                                                                        % Horizontal offset
    y_offset = 0.9;                                                                        % Vertical offset
    pos(:,1) = pos(:,1) * sqrt(3)/1.73;                                                    % Horizontal scale
    pos(:,2) = pos(:,2) * 1.155;                                                           % Vertical scale

    for i = 1:length(hit_surfaceGP)                                                        % Loop through each SOM unit
        if hit_surfaceGP(i) > 0                                                            % Only label units that have one or more hits
            text(pos(i,1) + x_offset, pos(i,2) + y_offset, num2str(hit_surfaceGP(i)), ...  % Place text near the unit showing the hit count
                  'Color', 'r', 'FontSize', 6, 'FontWeight', 'bold');                      % Set text color, size, and bold font for visibility
        end
    end
    title(sprintf('SOM Hit Numbers Slice at -%.1f m', dpth_m));                            % Add a title to the plot
    filename = sprintf('MeHg_SOM_Hit_Numbers_Slice_at_-%.1f_m.png', dpth_m);               % Create filename based on title
    saveas(gcf, filename);                                                                 % Save current figure as PNG

    clear i k     % Clear temporary variables from workspace
end




%% =============================================================
%% ============= SAVING LOOP FOR MULTIPLE Z-LEVELS =============
%% =============================================================
z_level = [1, 5, 8, 11, 14, 16, 26];                                % Define indices of depth slices to process
slice   = [z_level];                                                % Copy z_level into slice variable
dpths_m = [1.0182, 10.537, 19.398, 29.886, 42.145, 51.38, 112.25];  % Depths in meters corresponding to indices


%% ===================== 1. Initialise =====================
baseFolder = 'Cossarini_Model_Output';                                               % Folder containing data files
fileNames = { ...                                                                    % List of .nc filenames
    '20200101_y-CMCC--PSAL-MFSe3r1-MED-b20220901_re-sv01.00.nc', ...                 % Salinity
    '20200101_y-CMCC--TEMP-MFSe3r1-MED-b20220901_re-sv01.00.nc', ...                 % Temperature
    '20200101_y-OGS--BIOL-MedBFM3-MED-b20221120_re-sv05.00.nc' ...                   % Oxygen
};
files = cellfun(@(f) fullfile(baseFolder, f), fileNames, 'UniformOutput', false);    % Create full paths for files


%% =================== 2. Load .nc files ===================
% Load once outside the loop to save time
ncid = netcdf.open(files{1}, 'NC_NOWRITE');                   % Open first file (salinity)
dataso = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'so'));    % Read salinity variable
netcdf.close(ncid);                                           % Close the file
ncid = netcdf.open(files{2}, 'NC_NOWRITE');                   % Open second file (temperature)
dataT = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'thetao')); % Read temperature variable
netcdf.close(ncid);
ncid = netcdf.open(files{3}, 'NC_NOWRITE');                   % Open third file (oxygen)
dataO = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'o2'));     % Read oxygen variable
netcdf.close(ncid);

ncid = netcdf.open(files{1}, 'NC_NOWRITE');                   % Re-open first file to get latitude
datalat = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'lat'));  % Read latitude
netcdf.close(ncid);
ncid = netcdf.open(files{1}, 'NC_NOWRITE');                   % Re-open first file to get longitude
datalon = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'lon'));  % Read longitude
netcdf.close(ncid);
ncid = netcdf.open(files{1}, 'NC_NOWRITE');                   % Re-open first file to get depth
varid = netcdf.inqVarID(ncid, 'depth');                       % Get variable ID for depth
datadepth = netcdf.getVar(ncid, varid);                       % Read depth variable

% Subset to region/depth range
dataT = dataT(12:end, :, 1:125);                   % Keep subset of temperature data
dataso = dataso(12:end, :, 1:125);                 % Keep subset of salinity data
datalon = datalon(12:end);                         % Subset longitude

% Create coordinate indexing
[lat_grid, lon_grid] = meshgrid(datalat,datalon);  % Create 2D grid of lat/lon
flat_lat = lat_grid(:);                            % Flatten latitude grid
flat_lon = lon_grid(:);                            % Flatten longitude grid
latlon_matrix = [flat_lat, flat_lon];              % Combine lat/lon into single matrix


%% ===================== 3. Loop over depth slices =====================
for n = 1:length(slice)                            % Loop over each depth slice

    %% ========== Data Preparation ===============
    latlon_sliced = latlon_matrix;                 % Copy lat/lon for current slice
    idx = slice(n);                                % Current depth index
    dpth_m = dpths_m(n);                           % Current depth in meters

    fprintf('\nProcessing depth index %d (%.1f m)...\n', idx, dpth_m);  % Print processing info

    slicedataT  = dataT(:, :, idx);                           % Extract temperature at current depth
    slicedataO  = dataO(:, :, idx);                           % Extract oxygen at current depth
    slicedataso = dataso(:, :, idx);                          % Extract salinity at current depth

    slicedataT  = slicedataT(:);                              % Flatten temperature
    slicedataO  = slicedataO(:);                              % Flatten oxygen
    slicedataso = slicedataso(:);                             % Flatten salinity

    latlon_sliced(slicedataT == 1e+20, :) = [];               % Remove lat/lon where temperature is missing
    slicedataT(slicedataT == 1e+20) = [];                     % Remove missing temperature values
    slicedataO(slicedataO == 1e+20) = [];                     % Remove missing oxygen values
    slicedataso(slicedataso == 1e+20) = [];                   % Remove missing salinity values

    slicedata = cat(2, slicedataT, slicedataso, slicedataO);  % Combine T, Sal, O2 into one matrix

    %% ========== Data Elaboration ===============
    sData_cossarini = som_data_struct(slicedata, 'name', 'Cossarini Dataset', 'comp_names', {'Temp','Sal','O2_uM'});  % Create SOM data struct

    sData_cossarini_newT  = som_normalize(sData_cossarini.data(:,1), sData.comp_norm{2});  % Normalize temperature
    sData_cossarini_newSO = som_normalize(sData_cossarini.data(:,2), sData.comp_norm{3});  % Normalize salinity
    sData_cossarini_newO  = som_normalize(sData_cossarini.data(:,3), sData.comp_norm{4});  % Normalize oxygen

    nRows = size(sData_cossarini_newT, 1);                                                               % Number of rows in normalized temperature
    nan_col = nan(nRows, 1);                                                                             % Create column of NaNs for alignment
    sData_cossarini_new = [nan_col, sData_cossarini_newT, sData_cossarini_newSO, sData_cossarini_newO];  % Combine NaN + normalized data
    bmus_surfaceGP = som_bmus(sMap, sData_cossarini_new);                                                % Compute BMUs (best matching units)
    hg_codebook = sMap.codebook(bmus_surfaceGP, 1);                                                      % Extract corresponding codebook entries
    hg_codebook_denorm = som_denormalize(hg_codebook, sMap.comp_norm(1));                                % Denormalize BMU values

    nRows = size(sData_cossarini.data, 1);                             % Number of rows in original data
    nan_col = nan(nRows, 1);                                           % Create NaN column for alignment
    sData_cossarini.data = [nan_col, sData_cossarini.data];            % Add NaN column to original data
    sData_cossarini.data(:,1) = hg_codebook_denorm;                    % Replace first column with denormalized BMU values
    sData_cossarini.data = cat(2,latlon_sliced,sData_cossarini.data);  % Collate lat/lon to data

    varName = sprintf('sData_cossarini_%dm', round(dpth_m));      % Generate variable name based on depth
    fprintf('Saving variable: %s\n', varName);                    % Print saving info
    eval([varName ' = sData_cossarini.data;']);                   % Assign data to variable with dynamic name
    outputFile = 'MeHg_Cossarini_SOM_MultiZlevel.mat';            % Output .mat file name
    save(outputFile, varName, '-append');                         % Save variable to .mat in append mode

    %% ============ Plot Hg as a Map ============
    final_lon = flip(sData_cossarini.data(:,1));    % flip longitude data
    final_lat = flip(sData_cossarini.data(:,2));    % flip latitude data
    final_hg  = flip(sData_cossarini.data(:,3));    % flip mercury values

    figure(7+n);                                                     % create a new figure for each depth
    set(gcf, 'Position', [100, 100, 1200, 400]);                     % set figure size
    scatter(final_lat, final_lon, 10, final_hg, 'filled');           % plot scatter of mercury values
    colorbar;                                                        % show colorbar
    caxis([0 0.4]);                                                  % fix color scale from 0.0 to 0.4
    xlabel('Longitude');                                             % label x-axis
    ylabel('Latitude');                                              % label y-axis
    xlim([-7 36]);                                                   % ticks x-axis
    ylim([30 46]);                                                   % ticks y-axis
    title(sprintf('Depth: %.1f m', dpth_m));                         % set title with depth
    filename = sprintf('MeHg_Cossarini_depth_%.1f.png', dpth_m);     % prepare filename
    saveas(gcf, filename);                                           % save figure as PNG

end

fprintf('\nAll depths processed and saved to %s\n', outputFile);   % Print completion message

clear i idx k n varid         % Clear temporary variables from workspace




%% =============================================================
%% ===================== ROSATI MODEL ==========================
%% =============================================================
baseFolder_rosati = 'Rosati_Data_Model_Output/';       % Base folder containing NetCDF files
fileNames_rosati = { ...                               % List of NetCDF file names to process
    'ave.20140616-00_00_00.DMHg.nc', ...
    'ave.20140616-00_00_00.MMHg.nc', ...
};
files_rosati = cellfun(@(f) fullfile(baseFolder_rosati, f), fileNames_rosati, 'UniformOutput', false);  % Create full paths for all files
allVarNames_rosati = cell(1, numel(files_rosati));                                                      % Initialize cell array to store variable names for each file

ncid = netcdf.open(files_rosati{1}, 'NC_NOWRITE');  % Open first NetCDF file (PSAL) in read-only mode
varid = netcdf.inqVarID(ncid, 'DMHg');              % Get variable ID for 'so' (salinity)
datadmhg = netcdf.getVar(ncid, varid);              % Read the 'so' variable data into MATLAB/Octave
netcdf.close(ncid);                                 % Close the first NetCDF file
ncid = netcdf.open(files_rosati{2}, 'NC_NOWRITE');  % Open first NetCDF file (PSAL) in read-only mode
varid = netcdf.inqVarID(ncid, 'MMHg');              % Get variable ID for 'so' (salinity)
datammhg = netcdf.getVar(ncid, varid);              % Read the 'so' variable data into MATLAB/Octave
netcdf.close(ncid);                                 % Close the first NetCDF file

ncid = netcdf.open(files_rosati{1}, 'NC_NOWRITE');            % Re-open first file to get latitude
datalat = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'lat'));  % Read latitude
netcdf.close(ncid);
ncid = netcdf.open(files_rosati{1}, 'NC_NOWRITE');            % Re-open first file to get longitude
datalon = netcdf.getVar(ncid, netcdf.inqVarID(ncid, 'lon'));  % Read longitude
netcdf.close(ncid);
ncid = netcdf.open(files_rosati{1}, 'NC_NOWRITE');            % Re-open first file to get depth
varid = netcdf.inqVarID(ncid, 'depth');                       % Get variable ID for depth
datadepth = netcdf.getVar(ncid, varid);                       % Read depth variable

datamehg = datadmhg + datammhg;

clear i ncid nvars varname varid     % Clear temporary variables from workspace

z_level = [1, 5, 8, 11, 14, 16, 26];                                % Define indices of depth slices to process
slice   = [z_level];                                                % Copy z_level into slice variable
dpths_m = [1.0182, 10.537, 19.398, 29.886, 42.145, 51.38, 112.25];  % Depths in meters corresponding to indices

% Create coordinate indexing
[lat_grid, lon_grid] = meshgrid(datalat,datalon);  % Create 2D grid of lat/lon
flat_lat = lat_grid(:);                            % Flatten latitude grid
flat_lon = lon_grid(:);                            % Flatten longitude grid
latlon_matrix = [flat_lat, flat_lon];              % Combine lat/lon into single matrix

%% ===================== 1. Loop over depth slices =====================
for n = 1:length(slice)         % Loop over each depth slice

    %% ========== Data Preparation ===============
    idx = slice(n);             % Current depth index
    dpth_m = dpths_m(n);        % Current depth in meters
    fprintf('\nProcessing depth index %d (%.1f m)...\n', idx, dpth_m);

    slicedataME = datamehg(:, :, idx);  % Extract combined MEHg at current depth
    slicedataME = slicedataME(:);       % Flatten MEHg

    latlon_sliced = latlon_matrix;      % Copy lat/lon for current slice


    mask = (slicedataME == 2e+20);      % Remove missing values (assuming missing values are 1e+20 as in previous code)
    latlon_sliced(mask, :) = [];
    slicedataME(mask) = [];

    sData_rosati = cat(2, latlon_sliced, slicedataME);

    %% ========== Data Elaboration ===============
    varName = sprintf('sData_rosati_%dm', round(dpth_m));
    fprintf('Saving variable: %s\n', varName);
    eval([varName ' = sData_rosati;']);

    outputFile = 'MeHg_Rosati_MultiZlevel.mat';
    save(outputFile, varName, '-append');   % Save to .mat file (append)

    %% ============ Plot MEHg as a Map ============
    final_lon = flip(latlon_sliced(:,1));   % flip longitude
    final_lat = flip(latlon_sliced(:,2));   % flip latitude
    final_mehg = flip(slicedataME);         % flip MEHg values

    figure(14+n);                                                 % new figure for each depth
    set(gcf, 'Position', [100, 100, 1200, 400]);                  % set figure size
    scatter(final_lat, final_lon, 10, final_mehg, 'filled');      % scatter plot
    colorbar;                                                     % show colorbar
    caxis([0 0.4]);                                               % fix color scale from 0.0 to 0.4
    xlabel('Longitude');                                          % label x-axis
    ylabel('Latitude');                                           % label y-axis
    xlim([-7 36]);                                                % ticks x-axis
    ylim([30 46]);                                                % ticks y-axis
    title(sprintf('ROSATI Model MEHg - Depth: %.1f m', dpth_m));  % set title with depth
    filename = sprintf('MeHg_Rosati_depth_%.1f.png', dpth_m);     % prepare filename
    saveas(gcf, filename);                                        % save figure as PNG

end

fprintf('\nAll ROSATI depths processed and saved to %s\n', outputFile);   % Print completion message

clear idx n mask latlon_sliced final_lat final_lon final_mehg    % Clear temporary variables from workspace




%% ============================================================
%% ====================== ERROR MEASURE =======================
%% ============================================================
clear  % clear workspace

%% ============ Load Data ============
load('MeHg_Cossarini_SOM_MultiZlevel.mat')
load('MeHg_Rosati_MultiZlevel.mat')
depths = {'1m', '11m', '19m', '30m', '42m', '51m', '112m'};   % list of model depth levels

%% ============ Custom Red-White-Blue Colorbar ============
function cmap = redwhiteblue(n)                 % define red-white-blue colormap
  if nargin < 1
      n = 256;                                  % default number of colors
  end
  half = floor(n/2);                            % split color range in half
  r = [(0:half-1)'/half; ones(half,1)];         % red increases from 01, stays 1
  g = [(0:half-1)'/half; (half-1:-1:0)'/half];  % green goes up then down
  b = [ones(half,1); (half-1:-1:0)'/half];      % blue starts at 1 then fades
  cmap = [r g b];                               % combine RGB into colormap
end


%% ============ Main Loop ============
for n = 1:length(depths)                        % Loop over each depth slice
  depth = depths{n};                            % current depth string (e.g. '1m')

  coss_name = ['sData_cossarini_' depth];       % sData_cossarini_1m
  ros_name  = ['sData_rosati_' depth];          % sData_rosati_1m

  coss_data = eval(coss_name);                  % get matrix from workspace
  ros_data  = eval(ros_name);                   % get matrix from workspace

  lat_c = coss_data(:,1);                       % Cossarini latitude
  lon_c = coss_data(:,2);                       % Cossarini longitude
  val_c = coss_data(:,3);                       % Cossarini value
  lat_r = ros_data(:,1);                        % Rosati latitude
  lon_r = ros_data(:,2);                        % Rosati longitude
  val_r = ros_data(:,3);                        % Rosati value

  coords_c = [lat_c, lon_c];                    % coordinates from Cossarini
  coords_r = [lat_r, lon_r];                    % coordinates from Rosati

  [common_coords, idx_c, idx_r] = intersect(coords_c, coords_r, 'rows'); % match by (lat, lon)

  diff_val = val_c(idx_c) - val_r(idx_r);       % difference of third column
  diff_data = [common_coords, diff_val];        % combined result [lat lon diff]

  diff_name = sprintf('diff_%s', depth);                % Create variable name (e.g. diff_1m)
  fprintf('Saving variable: %s\n', diff_name);          % Announce what is being saved
  eval([diff_name ' = diff_data;']);                    % Assign dynamically
  outputFile = 'MeHg_Difference_Cossarini_Rosati.mat';  % Save to .mat file (append mode)
  save(outputFile, diff_name, '-append');

  %% ============ Plot Difference ============
  figure(14 + n);                               % create a new figure per depth
  set(gcf, 'Position', [100, 100, 1200, 400]);  % set figure window size
  ax = gca;
  hold on;
  fill([-7 36 36 -7], [30 30 46 46], [0.8 0.8 0.8], 'EdgeColor', 'none');   % gray background (land)
  scatter(common_coords(:,2), common_coords(:,1), 10, diff_val, 'filled');  % scatter plot colored by diff
  colormap(redwhiteblue());                                                 % apply red-white-blue colormap
  colorbar;                                                                 % show color scale

  clim = max(abs(diff_val));    % find max abs difference
  caxis([-clim clim]);          % symmetric color axis limits

  xlabel('Longitude');                                                                       % X label
  ylabel('Latitude');                                                                        % Y label
  xlim([-7 36]);                                                                             % longitude range
  ylim([30 46]);                                                                             % latitude range
  title(sprintf('Cossarini - Rosati Difference at Depth: %s', depth), 'FontWeight', 'bold'); % title

  filename = sprintf('MeHg_Difference_Cossarini_minus_Rosati_%s.png', depth);  % output file name
  saveas(gcf, filename);                                                  % save figure to file

  fprintf('Depth %s: computed %d matching points and saved plot "%s".\n', depth, rows(diff_data), filename);  % print progress info

end

clear ax clim common_coords coords_c coords_r coss_data coss_name ...    % Clear temporary variables from workspace
  depth depths diff_data diff_name diff_val filename ...                 % Clear temporary variables from workspace
  idx_c idx_r lat_c lat_r lon_c lon_r ros_data n ros_name val_c val_r    % Clear temporary variables from workspace




%% ============================================================
%% ===================== CLOSE ALL PLOTS ======================
%% ============================================================
close all           # Close all plots
##### SOURCE END #####
-->
</body>
</html>
